<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Przekierowanie | Łukasz Guziczak</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap');

    :root {
      --primary-color: #0070f3;
      --primary-dark: #0050a0;
      --secondary-color: #34d399;
      --tertiary-color: #8b5cf6;
      --light-bg: #f9fafb;
      --dark-bg: #111827;
      --light-card: #ffffff;
      --dark-card: #1f2937;
      --light-text: #1f2937;
      --dark-text: #f3f4f6;
      --gray-text: #6b7280;
      --card-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --dark-card-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.25), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
      --border-radius: 12px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --heading-font: 'Poppins', 'Segoe UI', sans-serif;
      --body-font: 'Inter', 'Roboto', 'Arial', sans-serif;
      --transition-bezier: cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background-color: var(--light-bg);
      color: var(--light-text);
      height: 100vh;
      overflow: hidden;
      font-family: var(--body-font);
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    body.dark-mode {
      background-color: var(--dark-bg);
      color: var(--dark-text);
    }
    
    /* Subtle gradient overlay to match main site */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 70% 30%, rgba(0, 112, 243, 0.08) 0%, rgba(0, 0, 0, 0) 60%);
      pointer-events: none;
      z-index: -1;
    }
    
    body.dark-mode::before {
      background: radial-gradient(circle at 70% 30%, rgba(0, 112, 243, 0.15) 0%, rgba(0, 0, 0, 0) 70%);
    }
    
    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: none;
      border: none;
      cursor: pointer;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--light-text);
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 50%;
      z-index: 200;
      transition: var(--transition);
      backdrop-filter: blur(4px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    
    /* Light mode specific toggle styling to match main site */
    body:not(.dark-mode) .theme-toggle {
      background-color: rgba(0, 0, 0, 0.05);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(0, 0, 0, 0.05);
    }
    
    /* Dark mode specific toggle styling to match main site */
    body.dark-mode .theme-toggle {
      background-color: rgba(255, 255, 255, 0.1);
      color: var(--dark-text);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .theme-toggle:hover {
      background-color: rgba(0, 112, 243, 0.1);
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    .theme-toggle:active {
      transform: translateY(-1px);
    }
    
    /* Background elements */
    .background-elements {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      overflow: hidden;
      pointer-events: none;
    }

    .bg-gradient {
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0) 70%);
      animation: pulse-bg 15s ease infinite;
    }

    .light-rays {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(
        ellipse at 50% -20%,
        rgba(0, 112, 243, 0.08) 0%,
        rgba(0, 0, 0, 0) 70%
      );
      pointer-events: none;
    }

    body.dark-mode .light-rays {
      background: radial-gradient(
        ellipse at 50% -20%,
        rgba(0, 112, 243, 0.15) 0%,
        rgba(0, 0, 0, 0) 70%
      );
    }

    /* Background particles styling */
    .floating-particle {
      position: absolute;
      background-color: var(--primary-color);
      border-radius: 50%;
      filter: blur(1px);
      opacity: 0.05;
      animation: float-subtle 15s infinite ease-in-out;
    }
    
    body.dark-mode .floating-particle {
      opacity: 0.07;
    }
    
    /* Subtle floating animation */
    @keyframes float-subtle {
      0%, 100% {
        transform: translate(0, 0);
      }
      25% {
        transform: translate(var(--x-offset), var(--y-offset));
      }
      50% {
        transform: translate(calc(var(--x-offset) * 0.3), calc(var(--y-offset) * -0.8));
      }
      75% {
        transform: translate(calc(var(--x-offset) * -0.5), calc(var(--y-offset) * 0.3));
      }
    }

    @keyframes pulse-bg {
      0%, 100% {
        opacity: 0.8;
        transform: scale(1);
      }
      50% {
        opacity: 1;
        transform: scale(1.05);
      }
    }
    
    /* Bubble container */
    .bubble-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Main bubble styles - more organic and non-uniform shapes */
    .bubble {
      position: absolute;
      background: rgba(0, 112, 243, 0.25);
      box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.3),
                  0 0 15px rgba(0, 112, 243, 0.2);
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      justify-content: center;
      transform-origin: center;
      will-change: transform, border-radius;
      transition: box-shadow 0.3s ease;
      /* Super organic default shape applied before any animations */
      animation: wobble-shape 3s infinite alternate ease-in-out;
    }
    
    /* Light mode specific bubble styling to match main site */
    body:not(.dark-mode) .bubble {
      background: rgba(0, 112, 243, 0.25);
      box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.3),
                  0 5px 15px rgba(0, 112, 243, 0.15);
      border: 1px solid rgba(0, 112, 243, 0.3);
    }
    
    /* Dark mode specific bubble styling to match main site */
    body.dark-mode .bubble {
      background: rgba(0, 112, 243, 0.3);
      box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.15),
                  0 5px 15px rgba(0, 112, 243, 0.2);
    }
    
    /* Continuous organic shape morphing */
    @keyframes wobble-shape {
      0% {
        border-radius: 48% 52% 47% 53% / 52% 47% 53% 48%;
      }
      20% {
        border-radius: 54% 46% 50% 50% / 45% 55% 49% 51%;
      }
      40% {
        border-radius: 51% 49% 55% 45% / 53% 47% 44% 56%;
      }
      60% {
        border-radius: 46% 54% 49% 51% / 48% 52% 56% 44%;
      }
      80% {
        border-radius: 52% 48% 43% 57% / 51% 49% 52% 48%;
      }
      100% {
        border-radius: 47% 53% 52% 48% / 49% 51% 46% 54%;
      }
    }
    
    /* Main bubble */
    .main-bubble {
      width: 140px;
      height: 140px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 3;
      animation: float-random 5s ease-in-out infinite, wobble-shape 3s infinite alternate ease-in-out;
    }

    /* Realistic random floating animation */
    @keyframes float-random {
      0% {
        transform: translate(-50%, -50%) translateY(0);
      }
      25% {
        transform: translate(-52%, -48%) translateY(-5px);
      }
      50% {
        transform: translate(-50%, -52%) translateY(-10px);
      }
      75% {
        transform: translate(-48%, -50%) translateY(-5px);
      }
      100% {
        transform: translate(-50%, -50%) translateY(0);
      }
    }
    
    /* More realistic lighting effects - subtle and natural */
    .highlight {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.35);
      filter: blur(2px);
      opacity: 0.7;
    }
    
    /* Light mode highlights */
    body:not(.dark-mode) .highlight {
      background: rgba(255, 255, 255, 0.45);
      filter: blur(2px);
      opacity: 0.75;
    }
    
    /* Dark mode highlights */
    body.dark-mode .highlight {
      background: rgba(255, 255, 255, 0.3);
      filter: blur(2.5px);
      opacity: 0.65;
    }
    
    /* Main highlight - realistic top-left light source */
    .highlight-main {
      width: 30%;
      height: 30%;
      top: 15%;
      left: 15%;
      border-radius: 70% 30% 50% 50% / 60% 40% 60% 40%;
      transform: rotate(-15deg);
      animation: subtle-highlight 8s infinite ease-in-out;
    }
    
    /* Secondary highlight - realistic reflection pattern */
    .highlight-small {
      width: 12%;
      height: 10%;
      top: 40%;
      left: 25%;
      border-radius: 40% 60% 55% 45% / 45% 55% 60% 40%;
      transform: rotate(25deg);
      animation: subtle-highlight 8s infinite ease-in-out reverse;
    }
    
    @keyframes subtle-highlight {
      0%, 100% {
        opacity: 0.65;
        transform: rotate(-15deg) scale(1);
      }
      50% {
        opacity: 0.85;
        transform: rotate(-12deg) scale(1.05);
      }
    }

    @keyframes pulse-highlight {
      0%, 100% {
        opacity: 0.7;
      }
      50% {
        opacity: 0.9;
      }
    }

    /* Spinner in main bubble */
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1.2s cubic-bezier(0.5, 0.1, 0.5, 1) infinite;
    }
    
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    
    /* Redirect bubble - initially hidden */
    .redirect-bubble {
      width: 70px;
      height: 70px;
      left: calc(50% + 60px);
      top: calc(50% - 20px);
      opacity: 0;
      transform: translate(-50%, -50%) scale(0);
      cursor: pointer;
      z-index: 20; /* Higher z-index to be on top */
      box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.3),
                  0 0 10px rgba(0, 112, 243, 0.2);
      transition: box-shadow 0.3s ease;
      animation: wobble-shape-small 2s infinite alternate ease-in-out;
    }
    
    /* Faster wobbling for smaller bubble */
    @keyframes wobble-shape-small {
      0% {
        border-radius: 53% 47% 49% 51% / 47% 53% 52% 48%;
      }
      25% {
        border-radius: 56% 44% 52% 48% / 51% 49% 47% 53%;
      }
      50% {
        border-radius: 48% 52% 54% 46% / 49% 51% 53% 47%;
      }
      75% {
        border-radius: 51% 49% 46% 54% / 54% 46% 48% 52%;
      }
      100% {
        border-radius: 55% 45% 51% 49% / 45% 55% 50% 50%;
      }
    }

    .redirect-bubble:hover {
      box-shadow: inset 0 0 18px rgba(255, 255, 255, 0.4),
                  0 0 12px rgba(0, 112, 243, 0.15);
    }
    
    /* Arrow in redirect bubble */
    .arrow {
      position: relative;
      width: 20px;
      height: 20px;
      opacity: 0.9;
      transform: scale(0.8);
      transition: transform 0.3s ease;
    }
    
    .arrow::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-top: 3px solid white;
      border-right: 3px solid white;
      transform: rotate(45deg);
    }

    .redirect-bubble:hover .arrow {
      transform: scale(1) translateX(2px);
    }
    
    /* Bubble connection and tiny bubbles */
    .bubble-connector {
      position: absolute;
      z-index: 1;
      background: rgba(0, 112, 243, 0.12);
      box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.5),
                  0 0 10px rgba(0, 112, 243, 0.1);
      backdrop-filter: blur(3px);
      opacity: 0;
      border-radius: 40% 60% 50% 50% / 40% 50% 50% 60%;
      transform-origin: left center;
      left: 50%;
      top: 50%;
    }

    .tiny-bubble {
      position: absolute;
      background: rgba(0, 112, 243, 0.15);
      border-radius: 50%;
      opacity: 0;
      box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.6),
                  0 0 5px rgba(0, 112, 243, 0.15);
      z-index: 1;
      transform: scale(0);
    }
    
    /* Final animation states */
    .redirect-floating {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
      animation: float-redirect-organic 4s ease-in-out infinite, 
                 wobble-shape-small 2s infinite alternate ease-in-out,
                 pulse-redirect-subtle 2s infinite alternate !important;
    }

    .main-floating {
      animation: float-main-organic 6s ease-in-out infinite, 
                 wobble-shape 3s infinite alternate ease-in-out !important;
      transform: translate(-50%, -50%) scale(0.9) !important;
    }

    /* Realistic organic movement for main bubble after separation */
    @keyframes float-main-organic {
      0% {
        transform: translate(-50%, -50%) scale(0.9);
      }
      25% {
        transform: translate(-51%, -52%) scale(0.9) translateY(-7px);
      }
      50% {
        transform: translate(-50%, -48%) scale(0.9) translateY(-12px);
      }
      75% {
        transform: translate(-49%, -52%) scale(0.9) translateY(-7px);
      }
      100% {
        transform: translate(-50%, -50%) scale(0.9);
      }
    }

    /* Organic floating for redirect bubble */
    @keyframes float-redirect-organic {
      0% {
        transform: translate(-50%, -50%) scale(1);
      }
      33% {
        transform: translate(-48%, -51%) scale(1) translateY(-5px);
      }
      66% {
        transform: translate(-52%, -49%) scale(1) translateY(-10px);
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Subtle pulse effect */
    @keyframes pulse-redirect-subtle {
      0% {
        box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.3),
                    0 0 5px rgba(0, 112, 243, 0.1),
                    0 0 0 0 rgba(0, 112, 243, 0.1);
      }
      100% {
        box-shadow: inset 0 0 18px rgba(255, 255, 255, 0.4),
                    0 0 8px rgba(0, 112, 243, 0.15),
                    0 0 12px 5px rgba(0, 112, 243, 0.05);
      }
    }

    /* ULTRA-REALISTIC ORGANICALLY MORPHING BUBBLE ANIMATION */
    @keyframes mainBubbleDeform {
      0% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.35),
                    0 5px 15px rgba(0, 112, 243, 0.15);
      }
      5% {
        /* Begin developing slight asymmetry */
        transform: translate(-51%, -50%) scale(1.01, 0.995);
        border-radius: 52% 48% 47% 53% / 50% 50% 53% 47%;
      }
      10% {
        /* More asymmetry toward where new bubble will form */
        transform: translate(-52%, -50%) scale(1.02, 0.99);
        border-radius: 53% 47% 46% 54% / 50% 49% 54% 46%;
      }
      15% {
        /* Start of a protrusion */
        transform: translate(-52.5%, -50%) scale(1.03, 0.98);
        border-radius: 52% 48% 45% 55% / 49% 47% 56% 45%;
      }
      20% {
        /* Protrusion becoming more pronounced */
        transform: translate(-53%, -50%) scale(1.035, 0.975);
        border-radius: 50% 50% 43% 57% / 47% 45% 58% 44%;
      }
      25% {
        /* Further elongation in direction of future separation */
        transform: translate(-54%, -50%) scale(1.04, 0.97);
        border-radius: 47% 53% 41% 59% / 45% 43% 60% 42%;
      }
      30% {
        /* Maximum elongation before necking */
        transform: translate(-55%, -50%) scale(1.05, 0.965);
        border-radius: 44% 56% 40% 60% / 43% 41% 62% 40%;
      }
      35% {
        /* Beginning of necking (narrowing) between the bubbles */
        transform: translate(-56%, -50%) scale(1.055, 0.96);
        border-radius: 40% 60% 38% 62% / 40% 39% 64% 38%;
        box-shadow: inset 0 0 18px rgba(255, 255, 255, 0.32),
                    0 5px 12px rgba(0, 112, 243, 0.04);
      }
      40% {
        /* More pronounced necking */
        transform: translate(-57%, -50%) scale(1.06, 0.955);
        border-radius: 37% 63% 36% 64% / 38% 36% 66% 36%;
      }
      45% {
        /* Critical necking point - most stretched */
        transform: translate(-58%, -50%) scale(1.065, 0.95);
        border-radius: 34% 66% 33% 67% / 35% 33% 68% 34%;
      }
      /* Critical point where bubbles are separating */
      50% {
        transform: translate(-59%, -50%) scale(1.07, 0.945);
        border-radius: 32% 68% 31% 69% / 33% 30% 70% 32%;
        box-shadow: inset 0 0 16px rgba(255, 255, 255, 0.3),
                    0 5px 10px rgba(0, 112, 243, 0.04);
      }
      /* Surface tension rebound - rapid shape recovery */
      53% {
        transform: translate(-58%, -50%) scale(1.03, 0.97);
        border-radius: 36% 64% 38% 62% / 39% 37% 63% 38%;
      }
      56% {
        transform: translate(-57%, -50%) scale(0.99, 0.99);
        border-radius: 40% 60% 43% 57% / 44% 42% 58% 43%;
      }
      60% {
        /* Shape oscillation from surface tension */
        transform: translate(-56%, -50%) scale(0.96, 1.01);
        border-radius: 44% 56% 47% 53% / 48% 46% 54% 47%;
        box-shadow: inset 0 0 17px rgba(255, 255, 255, 0.31),
                    0 5px 11px rgba(0, 112, 243, 0.04);
      }
      64% {
        transform: translate(-55%, -50%) scale(0.94, 1.02);
        border-radius: 47% 53% 49% 51% / 50% 49% 51% 50%;
      }
      68% {
        /* Secondary oscillation */
        transform: translate(-54%, -50%) scale(0.93, 1.025);
        border-radius: 49% 51% 50% 50% / 51% 52% 48% 49%;
      }
      72% {
        transform: translate(-53%, -50%) scale(0.925, 1.02);
        border-radius: 50% 50% 51% 49% / 52% 53% 47% 48%;
        box-shadow: inset 0 0 18px rgba(255, 255, 255, 0.33),
                    0 5px 12px rgba(0, 112, 243, 0.045);
      }
      76% {
        /* Damping oscillation */
        transform: translate(-52%, -50%) scale(0.92, 1.015);
        border-radius: 51% 49% 52% 48% / 52.5% 53.5% 46.5% 47.5%;
      }
      80% {
        transform: translate(-51.5%, -50%) scale(0.915, 1.01);
        border-radius: 51.5% 48.5% 52.5% 47.5% / 52% 53% 47% 48%;
      }
      84% {
        /* Final subtle oscillations */
        transform: translate(-51%, -50%) scale(0.91, 1.005);
        border-radius: 51.8% 48.2% 52.8% 47.2% / 51.5% 52.5% 47.5% 48.5%;
      }
      88% {
        transform: translate(-50.5%, -50%) scale(0.905, 1);
        border-radius: 52% 48% 53% 47% / 51% 52% 48% 49%;
        box-shadow: inset 0 0 19px rgba(255, 255, 255, 0.34),
                    0 5px 13px rgba(0, 112, 243, 0.048);
      }
      92% {
        /* Settling toward final shape */
        transform: translate(-50.3%, -50%) scale(0.9025, 0.9975);
        border-radius: 51.5% 48.5% 52.5% 47.5% / 50.5% 51.5% 48.5% 49.5%;
      }
      96% {
        transform: translate(-50.1%, -50%) scale(0.901, 0.995);
        border-radius: 51.2% 48.8% 52.2% 47.8% / 50.2% 51% 49% 49.8%;
      }
      100% {
        /* Final stable state - slightly smaller with organic shape */
        transform: translate(-50%, -50%) scale(0.9);
        border-radius: 51% 49% 52% 48% / 50% 51% 49% 50%;
        box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.35),
                    0 5px 15px rgba(0, 112, 243, 0.05);
      }
    }

    /* ORGANIC BUBBLE FORMATION WITH NON-UNIFORM SHAPE */
    @keyframes newBubbleForm {
      0% {
        opacity: 0;
        transform: translate(-150%, -50%) scale(0.05);
        border-radius: 60% 40% 55% 45% / 55% 45% 55% 45%;
        box-shadow: inset 0 0 6px rgba(255, 255, 255, 0.2),
                    0 2px 5px rgba(0, 112, 243, 0.02);
      }
      10% {
        opacity: 0.1;
        transform: translate(-140%, -50%) scale(0.15);
        border-radius: 58% 42% 56% 44% / 54% 46% 53% 47%;
      }
      20% {
        opacity: 0.2;
        transform: translate(-130%, -50%) scale(0.25);
        border-radius: 57% 43% 54% 46% / 53% 47% 52% 48%;
        box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.22),
                    0 2px 6px rgba(0, 112, 243, 0.025);
      }
      30% {
        opacity: 0.35;
        transform: translate(-120%, -50%) scale(0.35);
        border-radius: 56% 44% 53% 47% / 52% 48% 51% 49%;
      }
      40% {
        opacity: 0.45;
        transform: translate(-110%, -50%) scale(0.45);
        border-radius: 55% 45% 52% 48% / 51% 49% 50% 50%;
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.25),
                    0 3px 7px rgba(0, 112, 243, 0.03);
      }
      /* Non-uniform growth as surface tension effects kick in */
      50% {
        opacity: 0.6;
        transform: translate(-100%, -50%) scale(0.55, 0.6);
        border-radius: 54% 46% 51% 49% / 49% 51% 49% 51%;
      }
      /* Wobble as bubble pinches off */
      55% {
        opacity: 0.68;
        transform: translate(-95%, -50%) scale(0.65, 0.62);
        border-radius: 51% 49% 53% 47% / 47% 53% 48% 52%;
      }
      60% {
        opacity: 0.75;
        transform: translate(-90%, -50%) scale(0.72, 0.68);
        border-radius: 49% 51% 54% 46% / 46% 54% 47% 53%;
        box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.28),
                    0 3px 8px rgba(0, 112, 243, 0.035);
      }
      65% {
        opacity: 0.82;
        transform: translate(-85%, -50%) scale(0.78, 0.75);
        border-radius: 47% 53% 52% 48% / 48% 52% 47% 53%;
      }
      70% {
        opacity: 0.85;
        transform: translate(-80%, -50%) scale(0.82, 0.83);
        border-radius: 48% 52% 50% 50% / 50% 50% 48% 52%;
      }
      /* Natural oscillation as bubble stabilizes */
      75% {
        opacity: 0.88;
        transform: translate(-75%, -50%) scale(0.85, 0.9);
        border-radius: 50% 50% 48% 52% / 52% 48% 50% 50%;
        box-shadow: inset 0 0 14px rgba(255, 255, 255, 0.3),
                    0 4px 9px rgba(0, 112, 243, 0.04);
      }
      80% {
        opacity: 0.92;
        transform: translate(-70%, -50%) scale(0.9, 0.87);
        border-radius: 52% 48% 49% 51% / 51% 49% 52% 48%;
      }
      85% {
        opacity: 0.95;
        transform: translate(-65%, -50%) scale(0.94, 0.97);
        border-radius: 53% 47% 50% 50% / 49% 51% 51% 49%;
      }
      /* Final stabilization with organic shape */
      90% {
        opacity: 0.97;
        transform: translate(-60%, -50%) scale(0.97, 0.96);
        border-radius: 53% 47% 51% 49% / 48% 52% 50% 50%;
        box-shadow: inset 0 0 16px rgba(255, 255, 255, 0.32),
                    0 4px 10px rgba(0, 112, 243, 0.045);
      }
      95% {
        opacity: 0.99;
        transform: translate(-55%, -50%) scale(0.99, 1.01);
        border-radius: 53% 47% 51.5% 48.5% / 48.5% 51.5% 49.5% 50.5%;
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        border-radius: 53% 47% 52% 48% / 49% 51% 50% 50%;
        box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.35),
                    0 5px 15px rgba(0, 112, 243, 0.05);
      }
    }

    @keyframes connectorAnimation {
      0% {
        opacity: 0;
        width: 0;
        height: 0;
        transform: scaleX(0) translateX(0);
        border-radius: 50%;
        box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.3),
                    0 0 5px rgba(0, 112, 243, 0.1);
      }
      /* Initial formation - connector starts to form */
      5% {
        opacity: 0.2;
        width: 10px;
        height: 8px;
        transform: scaleX(0.1) translateX(5px);
        border-radius: 48% 52% 48% 52% / 50% 50% 50% 50%;
      }
      10% {
        opacity: 0.4;
        width: 20px;
        height: 15px;
        transform: scaleX(0.2) translateX(10px);
        border-radius: 45% 55% 45% 55% / 50% 50% 50% 50%;
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.4),
                    0 0 8px rgba(0, 112, 243, 0.15);
      }
      /* Growth phase - connector stretches as bubbles move apart */
      20% {
        opacity: 0.6;
        width: 30px;
        height: 20px;
        transform: scaleX(0.35) translateX(20px);
        border-radius: 42% 58% 42% 58% / 48% 52% 48% 52%;
      }
      30% {
        opacity: 0.8;
        width: 40px;
        height: 25px;
        transform: scaleX(0.5) translateX(30px);
        border-radius: 40% 60% 40% 60% / 45% 55% 45% 55%;
        box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.5),
                    0 0 10px rgba(0, 112, 243, 0.2);
      }
      /* Maximum extension point */
      40% {
        opacity: 0.9;
        width: 45px;
        height: 28px;
        transform: scaleX(0.6) translateX(35px);
        border-radius: 38% 62% 38% 62% / 42% 58% 42% 58%;
      }
      50% {
        opacity: 1;
        width: 50px;
        height: 30px;
        transform: scaleX(0.7) translateX(40px);
        border-radius: 35% 65% 35% 65% / 40% 60% 40% 60%;
        box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.55),
                    0 0 12px rgba(0, 112, 243, 0.22);
      }
      /* Thinning phase - connector begins to narrow in the middle */
      55% {
        opacity: 0.95;
        width: 48px;
        height: 28px;
        transform: scaleX(0.65) translateX(45px);
        border-radius: 36% 64% 36% 64% / 41% 59% 41% 59%;
      }
      60% {
        opacity: 0.9;
        width: 42px;
        height: 25px;
        transform: scaleX(0.6) translateX(50px);
        border-radius: 38% 62% 38% 62% / 43% 57% 43% 57%;
        box-shadow: inset 0 0 18px rgba(255, 255, 255, 0.5),
                    0 0 10px rgba(0, 112, 243, 0.2);
      }
      /* Necking - connector becomes very thin in the middle before breaking */
      65% {
        opacity: 0.85;
        width: 36px;
        height: 22px;
        transform: scaleX(0.55) translateX(55px);
        border-radius: 39% 61% 39% 61% / 44% 56% 44% 56%;
      }
      70% {
        opacity: 0.75;
        width: 30px;
        height: 20px;
        transform: scaleX(0.5) translateX(60px);
        border-radius: 40% 60% 40% 60% / 45% 55% 45% 55%;
        box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.45),
                    0 0 8px rgba(0, 112, 243, 0.18);
      }
      /* Breaking - connector is about to separate */
      75% {
        opacity: 0.65;
        width: 24px;
        height: 16px;
        transform: scaleX(0.45) translateX(65px);
        border-radius: 42% 58% 42% 58% / 47% 53% 47% 53%;
      }
      /* Post-break retraction and dissipation */
      80% {
        opacity: 0.5;
        width: 18px;
        height: 12px;
        transform: scaleX(0.35) translateX(70px);
        border-radius: 44% 56% 44% 56% / 48% 52% 48% 52%;
        box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.4),
                    0 0 6px rgba(0, 112, 243, 0.15);
      }
      85% {
        opacity: 0.35;
        width: 15px;
        height: 10px;
        transform: scaleX(0.25) translateX(75px);
        border-radius: 46% 54% 46% 54% / 49% 51% 49% 51%;
      }
      90% {
        opacity: 0.2;
        width: 10px;
        height: 8px;
        transform: scaleX(0.15) translateX(85px);
        border-radius: 48% 52% 48% 52% / 49% 51% 49% 51%;
        box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.35),
                    0 0 4px rgba(0, 112, 243, 0.1);
      }
      95% {
        opacity: 0.1;
        width: 5px;
        height: 4px;
        transform: scaleX(0.1) translateX(95px);
        border-radius: 49% 51% 49% 51% / 50% 50% 50% 50%;
      }
      100% {
        opacity: 0;
        width: 0;
        height: 0;
        transform: scaleX(0) translateX(100px);
        border-radius: 50%;
        box-shadow: inset 0 0 0 rgba(255, 255, 255, 0),
                    0 0 0 rgba(255, 255, 255, 0);
      }
    }

    @keyframes tinyBubbleRise {
      0% {
        opacity: 0;
        transform: translate(0, 0) scale(0);
        box-shadow: inset 0 0 3px rgba(255, 255, 255, 0.4),
                    0 0 2px rgba(0, 112, 243, 0.2);
      }
      /* Initial appearance with slight push effect */
      5% {
        opacity: 0.5;
        transform: translate(calc(var(--tx) * 0.1), calc(var(--ty) * 0.1)) scale(0.5);
      }
      10% {
        opacity: 1;
        transform: translate(calc(var(--tx) * 0.15), calc(var(--ty) * 0.15)) scale(1);
        box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5),
                    0 0 3px rgba(0, 112, 243, 0.3);
      }
      /* Movement phase - realistic fluid dynamics */
      20% {
        opacity: 0.95;
        transform: translate(calc(var(--tx) * 0.3), calc(var(--ty) * 0.3)) scale(0.95) rotate(calc(var(--tr) * 0.2));
      }
      /* Small bubbles wobble as they rise */
      30% {
        opacity: 0.9;
        transform: translate(calc(var(--tx) * 0.45 + var(--wobble-x)), calc(var(--ty) * 0.45)) scale(0.9) rotate(calc(var(--tr) * 0.4));
        box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.45),
                    0 0 2px rgba(0, 112, 243, 0.25);
      }
      40% {
        opacity: 0.85;
        transform: translate(calc(var(--tx) * 0.6 - var(--wobble-x)), calc(var(--ty) * 0.6)) scale(0.85) rotate(calc(var(--tr) * 0.6));
      }
      50% {
        opacity: 0.8;
        transform: translate(calc(var(--tx) * 0.7 + var(--wobble-x)), calc(var(--ty) * 0.7)) scale(0.75) rotate(calc(var(--tr) * 0.7));
        box-shadow: inset 0 0 3px rgba(255, 255, 255, 0.4),
                    0 0 2px rgba(0, 112, 243, 0.2);
      }
      60% {
        opacity: 0.7;
        transform: translate(calc(var(--tx) * 0.8 - var(--wobble-x)), calc(var(--ty) * 0.8)) scale(0.65) rotate(calc(var(--tr) * 0.8));
      }
      70% {
        opacity: 0.6;
        transform: translate(calc(var(--tx) * 0.85), calc(var(--ty) * 0.85)) scale(0.55) rotate(calc(var(--tr) * 0.9));
        box-shadow: inset 0 0 2px rgba(255, 255, 255, 0.35),
                    0 0 1px rgba(0, 112, 243, 0.15);
      }
      80% {
        opacity: 0.4;
        transform: translate(calc(var(--tx) * 0.9), calc(var(--ty) * 0.9)) scale(0.45) rotate(calc(var(--tr) * 0.95));
      }
      90% {
        opacity: 0.2;
        transform: translate(calc(var(--tx) * 0.95), calc(var(--ty) * 0.95)) scale(0.35) rotate(calc(var(--tr) * 0.98));
        box-shadow: inset 0 0 1px rgba(255, 255, 255, 0.3),
                    0 0 1px rgba(0, 112, 243, 0.1);
      }
      100% {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(0.3) rotate(var(--tr));
        box-shadow: inset 0 0 0 rgba(255, 255, 255, 0),
                    0 0 0 rgba(255, 255, 255, 0);
      }
    }

    /* Loading text styles */
    .loading-text {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-family: var(--heading-font);
      font-size: 0.9rem;
      color: var(--light-text);
      opacity: 0.8;
      text-align: center;
      transition: opacity 0.5s ease, transform 0.5s ease;
      padding: 8px 16px;
      border-radius: 20px;
      background-color: rgba(0, 112, 243, 0.1);
      backdrop-filter: blur(4px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    /* Light/dark mode variants matching main site */
    body:not(.dark-mode) .loading-text {
      background-color: rgba(0, 112, 243, 0.1);
      color: var(--light-text);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    body.dark-mode .loading-text {
      background-color: rgba(0, 112, 243, 0.15);
      color: var(--dark-text);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .loading-text.fade-out {
      opacity: a0;
      transform: translateX(-50%) translateY(10px);
    }
    
    /* Pulsating effect to attract attention after separation */
    .loading-text.pulse {
      animation: text-pulse 2s infinite alternate ease-in-out;
    }
    
    @keyframes text-pulse {
      0% {
        transform: translateX(-50%) scale(1);
      }
      100% {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }
    }

    /* Browser prefers reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .bubble, .redirect-bubble, .main-bubble, .tiny-bubble,
      .highlight, .spinner, .floating-particle {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body>
  <button class="theme-toggle" id="themeToggle" aria-label="Toggle dark mode">
    <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" id="themeIcon">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>

  <div class="background-elements">
    <div class="light-rays"></div>
    <!-- Custom background particles for ambient effect -->
    <div id="backgroundParticles"></div>
  </div>

  <div class="bubble-container" id="bubbleContainer">
    <!-- Main bubble with organic shape -->
    <div class="bubble main-bubble" id="mainBubble">
      <div class="highlight highlight-main"></div>
      <div class="highlight highlight-small"></div>
      <div class="spinner"></div>
    </div>
    <!-- Redirect bubble with slightly different organic shape -->
    <div class="bubble redirect-bubble" id="redirectBubble">
      <div class="highlight highlight-main"></div>
      <div class="highlight highlight-small"></div>
      <div class="arrow"></div>
    </div>
    <!-- Connector for bubble separation physics -->
    <div class="bubble-connector" id="bubbleConnector"></div>
  </div>

  <div class="loading-text" id="loadingText">
    Przekierowywanie...
  </div>

  <script>
    // Configuration
    const redirectUrl = "https://guziczak.github.io/lukasz/";
    const autoRedirectDelay = 5000; // ms before auto-redirect
    const splitStartDelay = 500;   // ms before bubble split animation starts
    const splitDuration = 1000;     // ms for the split animation
    
    document.addEventListener('DOMContentLoaded', () => {
      const body = document.body;
      const bubbleContainer = document.getElementById('bubbleContainer');
      const mainBubble = document.getElementById('mainBubble');
      const redirectBubble = document.getElementById('redirectBubble');
      const bubbleConnector = document.getElementById('bubbleConnector');
      const themeToggle = document.getElementById('themeToggle');
      const themeIcon = document.getElementById('themeIcon');
      const loadingText = document.getElementById('loadingText');
      const backgroundElements = document.querySelector('.background-elements');
      
      // Initialize theme based on user preference
      initTheme();
      
      // Create background particles
      createBackgroundParticles();
      
      // Redirect on click
      redirectBubble.addEventListener('click', () => {
        window.location.href = redirectUrl;
      });
      
      // Toggle theme
      themeToggle.addEventListener('click', toggleDarkMode);
      
      // Schedule the bubble split animation
      setTimeout(startBubbleSeparationAnimation, splitStartDelay);
      
      // Schedule auto-redirect
      setTimeout(() => {
        // Fade out loading text before redirect
        if (loadingText) loadingText.classList.add('fade-out');
        
        setTimeout(() => {
          window.location.href = redirectUrl;
        }, 500);
      }, autoRedirectDelay);
      
      // Theme initialization function
      function initTheme() {
        const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const savedTheme = localStorage.getItem('darkMode');
        
        if (savedTheme === 'true' || (savedTheme === null && prefersDarkMode)) {
          body.classList.add('dark-mode');
          themeIcon.innerHTML = '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>';
        }
      }
      
      // Toggle dark mode function
      function toggleDarkMode() {
        const isDark = body.classList.toggle('dark-mode');
        localStorage.setItem('darkMode', isDark);
        
        if (isDark) {
          themeIcon.innerHTML = '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>';
        } else {
          themeIcon.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>';
        }
      }
      
      // Create floating background particles
      function createBackgroundParticles() {
        if (!backgroundElements) return;
        
        for (let i = 0; i < 20; i++) {
          const particle = document.createElement('div');
          particle.className = 'floating-particle';
          
          // Random size between 3px and 12px
          const size = 3 + Math.random() * 9;
          particle.style.width = `${size}px`;
          particle.style.height = `${size}px`;
          
          // Random position
          const left = Math.random() * 100;
          const top = Math.random() * 100;
          particle.style.left = `${left}%`;
          particle.style.top = `${top}%`;
          
          // Random animation properties
          particle.style.setProperty('--x-offset', `${Math.random() * 100 - 50}px`);
          particle.style.setProperty('--y-offset', `${Math.random() * 100 - 50}px`);
          
          // Random animation delay
          particle.style.animationDelay = `${Math.random() * 5}s`;
          
          backgroundElements.appendChild(particle);
        }
      }
      
      // Main bubble separation animation
      function startBubbleSeparationAnimation() {
        // Set up bubble connector
        const mainRect = mainBubble.getBoundingClientRect();
        const containerRect = bubbleContainer.getBoundingClientRect();
        
        const mainCenterX = mainRect.left - containerRect.left + mainRect.width / 2;
        const mainCenterY = mainRect.top - containerRect.top + mainRect.height / 2;
        
        bubbleConnector.style.left = `${mainCenterX}px`;
        bubbleConnector.style.top = `${mainCenterY}px`;
        
        // Add initial wobble to bubbles before animation begins
        mainBubble.style.animation = 'wobble-shape 1.5s infinite alternate ease-in-out';
        
        setTimeout(() => {
          // Stop wobble animation and force a reflow to reset animation
          mainBubble.style.animation = 'none';
          void mainBubble.offsetWidth;
          
          // Start the main separation animations with precise physics
          mainBubble.style.animation = `mainBubbleDeform ${splitDuration}ms forwards cubic-bezier(0.34, 1.56, 0.64, 1)`;
          redirectBubble.style.animation = `newBubbleForm ${splitDuration}ms forwards cubic-bezier(0.34, 1.56, 0.64, 1)`;
          bubbleConnector.style.animation = `connectorAnimation ${splitDuration}ms forwards cubic-bezier(0.34, 1.56, 0.64, 1)`;
          
          // Create first wave of tiny bubbles at the precise moment of separation
          setTimeout(() => {
            createTinyBubbleEffect();
          }, splitDuration * 0.48); // Create bubbles at exact separation moment
          
          // After separation is complete
          setTimeout(() => {
            // Add floating animations to both bubbles and stop wobble-shape animation
            mainBubble.style.animation = 'none';
            redirectBubble.style.animation = 'none';
            
            // Force reflow
            void mainBubble.offsetWidth;
            void redirectBubble.offsetWidth;
            
            // Now add the new animation classes
            mainBubble.classList.add('main-floating');
            redirectBubble.classList.add('redirect-floating');
            
            // Update loading text with animation
            if (loadingText) {
              loadingText.textContent = 'Kliknij bąbelek, aby przejść dalej';
              loadingText.classList.add('pulse');
            }
            
            // Add extra subtle effects to enhance the feeling of completion
            addPostSeparationEffects();
          }, splitDuration + 100);
        }, 300); // Short delay before starting separation process
      }
      
      // Function to add subtle post-separation visual enhancements
      function addPostSeparationEffects() {
        // Add subtle pulse to redirect bubble's box-shadow
        const pulseStyle = document.createElement('style');
        pulseStyle.textContent = `
          .redirect-floating {
            animation: float-redirect-organic 4s ease-in-out infinite, 
                      pulse-redirect-subtle 2s infinite alternate !important;
          }
        `;
        document.head.appendChild(pulseStyle);
        
        // Add small background particles floating upward from the separation point
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            const particle = document.createElement('div');
            particle.className = 'floating-particle';
            
            // Small particles
            const size = 2 + Math.random() * 3;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            
            // Position near separation point
            const mainRect = mainBubble.getBoundingClientRect();
            const redirectRect = redirectBubble.getBoundingClientRect();
            const containerRect = bubbleContainer.getBoundingClientRect();
            
            const mainCenterX = mainRect.left - containerRect.left + mainRect.width / 2;
            const mainCenterY = mainRect.top - containerRect.top + mainRect.height / 2;
            const redirectCenterX = redirectRect.left - containerRect.left + redirectRect.width / 2;
            const redirectCenterY = redirectRect.top - containerRect.top + redirectRect.height / 2;
            
            const midX = (mainCenterX + redirectCenterX) / 2;
            const midY = (mainCenterY + redirectCenterY) / 2;
            
            particle.style.left = `${midX}px`;
            particle.style.top = `${midY}px`;
            
            // Random animation properties
            particle.style.setProperty('--x-offset', `${Math.random() * 40 - 20}px`);
            particle.style.setProperty('--y-offset', `${-30 - Math.random() * 30}px`);
            
            // Add to container
            bubbleContainer.appendChild(particle);
            
            // Remove after animation
            setTimeout(() => {
              particle.remove();
            }, 10000);
          }, i * 500); // Staggered creation
        }
      }
      
      // Create ultra-realistic tiny bubble effect when main bubble separates
      function createTinyBubbleEffect() {
        const mainRect = mainBubble.getBoundingClientRect();
        const redirectRect = redirectBubble.getBoundingClientRect();
        const containerRect = bubbleContainer.getBoundingClientRect();
        
        // Calculate the break point between the two bubbles
        const mainCenterX = mainRect.left - containerRect.left + mainRect.width / 2;
        const mainCenterY = mainRect.top - containerRect.top + mainRect.height / 2;
        const redirectCenterX = redirectRect.left - containerRect.left + redirectRect.width / 2;
        const redirectCenterY = redirectRect.top - containerRect.top + redirectRect.height / 2;
        
        // The exact point where bubbles are separating (closer to main bubble)
        const breakPointX = mainCenterX + (redirectCenterX - mainCenterX) * 0.4;
        const breakPointY = mainCenterY + (redirectCenterY - mainCenterY) * 0.4;
        
        // Vector for break direction - useful for realistic physics
        const breakAngle = Math.atan2(redirectCenterY - mainCenterY, redirectCenterX - mainCenterX);
        
        // Create two waves of tiny bubbles, between 15-25 bubbles total
        const numFirstWave = 8 + Math.floor(Math.random() * 5);
        const numSecondWave = 7 + Math.floor(Math.random() * 6);
        
        // First wave - immediate break bubbles
        createBubbleWave(numFirstWave, breakPointX, breakPointY, breakAngle, 0);
        
        // Second wave - slightly delayed bubbles (as if surface tension is still releasing tiny bubbles)
        setTimeout(() => {
          createBubbleWave(numSecondWave, breakPointX, breakPointY, breakAngle, 0.7);
        }, 100);
        
        function createBubbleWave(numBubbles, originX, originY, angle, waveOffsetFactor) {
          for (let i = 0; i < numBubbles; i++) {
            const tinyBubble = document.createElement('div');
            tinyBubble.className = 'tiny-bubble';
            
            // Add highlights to tiny bubbles for extra realism
            const highlight = document.createElement('div');
            highlight.className = 'highlight highlight-small';
            highlight.style.width = '40%';
            highlight.style.height = '40%';
            highlight.style.top = '20%';
            highlight.style.left = '20%';
            tinyBubble.appendChild(highlight);
            
            // More varied size distribution (tiny ones are more numerous in real fluid)
            // In real fluid dynamics, bubble size follows a lognormal distribution
            const sizeRandom = Math.random();
            let size;
            
            if (sizeRandom < 0.6) { // 60% chance of tiny bubbles
              size = 2 + sizeRandom * 3; // 2-5px
            } else if (sizeRandom < 0.9) { // 30% chance of medium bubbles
              size = 5 + (sizeRandom - 0.6) * 10 / 0.3; // 5-10px
            } else { // 10% chance of larger bubbles
              size = 10 + (sizeRandom - 0.9) * 5 / 0.1; // 10-15px
            }
            
            tinyBubble.style.width = `${size}px`;
            tinyBubble.style.height = `${size}px`;
            
            // Initial position with slight radial distribution from break point
            // Use break angle to determine primary direction of bubble dispersal
            const radialDistance = Math.random() * 12 * (1 + waveOffsetFactor);
            const radialAngle = angle + (Math.random() - 0.5) * Math.PI; // Dispersal cone ±90°
            
            const offsetX = Math.cos(radialAngle) * radialDistance;
            const offsetY = Math.sin(radialAngle) * radialDistance;
            
            tinyBubble.style.left = `${originX + offsetX}px`;
            tinyBubble.style.top = `${originY + offsetY}px`;
            
            // Physics-based direction vectors
            // Smaller bubbles are more affected by surface tension forces and fluid dynamics
            // Larger bubbles rise more directly upward
            const dispersalFactor = 1 - (size / 15); // Smaller bubbles disperse more randomly
            const primaryDirection = Math.PI / 2; // Upward direction
            
            // Blend between break direction and upward direction based on size
            const blendedAngle = angle * dispersalFactor + primaryDirection * (1 - dispersalFactor);
            
            // Add randomness proportional to size (smaller = more random)
            const finalAngle = blendedAngle + (Math.random() - 0.5) * Math.PI * dispersalFactor;
            
            // Distance proportional to size (larger bubbles travel farther)
            const baseDistance = 30 + size * 3;
            const distance = baseDistance + Math.random() * 40;
            
            // Larger bubbles rise faster due to buoyancy
            const speedFactor = 0.6 + (size / 10);
            
            // Calculate final movement vectors
            const tx = Math.sin(finalAngle) * distance * speedFactor;
            const ty = -Math.abs(Math.cos(finalAngle) * distance * speedFactor); // Always rise up
            
            // More rotation for smaller bubbles
            const tr = (Math.random() - 0.5) * (120 - size * 5); 
            
            // Path wobble for realistic fluid dynamics
            const wobbleX = Math.random() * 10 * (1 - size/15); // Smaller bubbles wobble more
            
            // Set CSS variables for animation
            tinyBubble.style.setProperty('--tx', `${tx}px`);
            tinyBubble.style.setProperty('--ty', `${ty}px`);
            tinyBubble.style.setProperty('--tr', `${tr}deg`);
            tinyBubble.style.setProperty('--wobble-x', `${wobbleX}px`);
            
            // Add to container
            bubbleContainer.appendChild(tinyBubble);
            
            // Staggered animation start times for more natural effect
            const startDelay = i * 15 + Math.random() * 30;
            
            // Varied animation duration based on size (smaller = faster dissipation)
            const duration = 0.7 + size/10 + Math.random() * 0.5;
            
            // Custom easing for each bubble
            const easingVariant = Math.floor(Math.random() * 3);
            let easing;
            
            switch(easingVariant) {
              case 0:
                easing = 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'; // easeOutQuad
                break;
              case 1:
                easing = 'cubic-bezier(0.55, 0.085, 0.68, 0.53)'; // easeInQuad
                break;
              case 2:
                easing = 'cubic-bezier(0.25, 0.1, 0.25, 1)'; // ease
                break;
            }
            
            // Start animation
            setTimeout(() => {
              tinyBubble.style.animation = `tinyBubbleRise ${duration}s ${easing} forwards`;
              
              // Remove after animation completes
              setTimeout(() => {
                tinyBubble.remove();
              }, duration * 1000 + 100);
            }, startDelay);
          }
        }
      }
    });
  </script>
</body>
</html>