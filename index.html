<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Przekierowanie | Łukasz Guziczak</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap');

    :root {
      --primary-color: #0070f3;
      --primary-dark: #0050a0;
      --secondary-color: #34d399;
      --light-bg: #f9fafb;
      --dark-bg: #111827;
      --light-text: #1f2937;
      --dark-text: #f3f4f6;
      --light-card: #ffffff;
      --dark-card: #1f2937;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --heading-font: 'Poppins', 'Segoe UI', sans-serif;
      --body-font: 'Inter', 'Roboto', 'Arial', sans-serif;
    }
    
    /* Animation state classes */
    .redirect-floating {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
      animation: float-redirect 4s ease-in-out infinite, wobble-shape 6s infinite linear, bubble-surface-tension 3s ease-in-out infinite !important;
    }
    
    .main-floating {
      animation: float-main-after 6s ease-in-out infinite, wobble-shape 6s infinite linear, bubble-surface-tension 4s ease-in-out infinite !important;
      transform: translate(-50%, -50%) scale(0.9) !important;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: var(--body-font);
      background-color: var(--light-bg);
      color: var(--light-text);
      height: 100vh;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: var(--transition);
    }

    body.dark-mode {
      background-color: var(--dark-bg);
      color: var(--dark-text);
    }

    /* Background gradient */
    .bg-gradient {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 70% 30%, rgba(0, 112, 243, 0.08) 0%, rgba(0, 0, 0, 0) 60%);
      z-index: -1;
      transition: var(--transition);
    }

    body.dark-mode .bg-gradient {
      background: radial-gradient(circle at 70% 30%, rgba(0, 112, 243, 0.15) 0%, rgba(0, 0, 0, 0) 70%);
    }
    
    /* Theme toggle button */
    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: none;
      border: none;
      cursor: pointer;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--light-text);
      background-color: rgba(0, 0, 0, 0.05);
      z-index: 100;
      transition: var(--transition);
      backdrop-filter: blur(4px);
      border: 1px solid rgba(0, 0, 0, 0.05);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    
    body.dark-mode .theme-toggle {
      background-color: rgba(255, 255, 255, 0.1);
      color: var(--dark-text);
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
    }
    
    .theme-toggle:hover {
      background-color: rgba(0, 112, 243, 0.1);
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    .theme-toggle:active {
      transform: translateY(-1px);
    }
    
    /* Bubble container */
    .bubble-container {
      position: relative;
      width: 300px;
      height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Base bubble styles - Improved visibility in light mode */
    .bubble {
      position: absolute;
      background: rgba(0, 112, 243, 0.4); /* Increased from 0.25 to 0.4 */
      box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.4),
                  0 0 15px rgba(0, 112, 243, 0.3),
                  0 0 0 1px rgba(0, 112, 243, 0.2); /* Added subtle border */
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      justify-content: center;
      transform-origin: center;
      transition: box-shadow 0.3s ease;
      will-change: transform, border-radius;
      border-radius: 51% 49% 48% 52% / 52% 47% 53% 48%;
      overflow: hidden;
    }
    
    body.dark-mode .bubble {
      background: rgba(0, 112, 243, 0.3);
      box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.15),
                  0 5px 15px rgba(0, 112, 243, 0.2);
    }
    
    /* Main bubble */
    .main-bubble {
      width: 140px;
      height: 140px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 3;
      animation: float-main 5s ease-in-out infinite, wobble-shape 6s infinite linear, bubble-surface-tension 4s ease-in-out infinite;
    }

    /* Redirect bubble - initially hidden */
    .redirect-bubble {
      width: 70px;
      height: 70px;
      left: calc(50% + 60px);
      top: calc(50% - 20px);
      opacity: 0;
      transform: translate(-50%, -50%) scale(0);
      cursor: pointer;
      z-index: 4;
      transition: var(--transition);
    }
    
    /* Highlights inside bubbles */
    .highlight {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.35);
      filter: blur(2px);
      opacity: 0.7;
      pointer-events: none;
    }
    
    body.dark-mode .highlight {
      background: rgba(255, 255, 255, 0.3);
      opacity: 0.65;
    }
    
    /* Main highlight */
    .highlight-main {
      width: 30%;
      height: 30%;
      top: 15%;
      left: 15%;
      border-radius: 70% 30% 50% 50% / 60% 40% 60% 40%;
      transform: rotate(-15deg);
      animation: pulse-highlight 8s infinite ease-in-out;
    }
    
    /* Secondary highlight */
    .highlight-small {
      width: 12%;
      height: 10%;
      top: 40%;
      left: 25%;
      border-radius: 40% 60% 55% 45% / 45% 55% 60% 40%;
      transform: rotate(25deg);
      animation: pulse-highlight 8s infinite ease-in-out reverse;
    }
    
    /* Spinner in main bubble */
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1.2s cubic-bezier(0.5, 0.1, 0.5, 1) infinite;
    }
    
    /* Arrow in redirect bubble */
    .arrow {
      position: relative;
      width: 20px;
      height: 20px;
      opacity: 0.9;
      transform: scale(0.8);
      transition: transform 0.3s ease;
    }
    
    .arrow::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-top: 3px solid white;
      border-right: 3px solid white;
      transform: rotate(45deg);
    }

    .redirect-bubble:hover .arrow {
      transform: scale(1) translateX(2px);
    }
    
    /* Bubble connector (initially hidden) */
    .bubble-connector {
      position: absolute;
      z-index: 1;
      background: rgba(0, 112, 243, 0.12);
      box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.5),
                  0 0 10px rgba(0, 112, 243, 0.1);
      backdrop-filter: blur(3px);
      opacity: 0;
      transform-origin: left center;
      left: 50%;
      top: 50%;
      width: 0;
      height: 0;
    }

    /* Tiny bubbles that appear during separation */
    .tiny-bubble {
      position: absolute;
      background: rgba(0, 112, 243, 0.15);
      border-radius: 50%;
      opacity: 0;
      box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.6),
                  0 0 5px rgba(0, 112, 243, 0.15);
      z-index: 2;
      transform: scale(0);
      pointer-events: none;
    }
    
    /* Loading text */
    .loading-text {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-family: var(--heading-font);
      font-size: 0.9rem;
      color: var(--light-text);
      opacity: 0.8;
      text-align: center;
      transition: opacity 0.5s ease, transform 0.5s ease;
      padding: 8px 16px;
      border-radius: 20px;
      background-color: rgba(0, 112, 243, 0.1);
      backdrop-filter: blur(4px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    body.dark-mode .loading-text {
      background-color: rgba(0, 112, 243, 0.15);
      color: var(--dark-text);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .loading-text.fade-out {
      opacity: 0;
      transform: translateX(-50%) translateY(10px);
    }
    
    .loading-text.pulse {
      animation: text-pulse 2s infinite alternate ease-in-out;
    }
    
    /* Background particles */
    .particles-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }
    
    .particle {
      position: absolute;
      background-color: var(--primary-color);
      border-radius: 50%;
      filter: blur(1px);
      opacity: 0.05;
      animation: float-particle 15s infinite ease-in-out;
    }
    
    body.dark-mode .particle {
      opacity: 0.07;
    }
    
    /* ANIMATIONS */
    
    /* Ulepszony wobble-shape - bardziej organiczne kształty z subtelniejszymi zmianami */
    @keyframes wobble-shape {
      0% {
        border-radius: 51% 49% 48% 52% / 52% 47% 53% 48%;
      }
      10% {
        border-radius: 52.5% 47.5% 49.5% 50.5% / 51% 49% 51.5% 48.5%;
      }
      20% {
        border-radius: 53.5% 46.5% 51% 49% / 49.5% 50.5% 50% 50%;
      }
      30% {
        border-radius: 52% 48% 52.5% 47.5% / 48% 52% 49% 51%;
      }
      40% {
        border-radius: 50.5% 49.5% 54% 46% / 51% 49% 46.5% 53.5%;
      }
      50% {
        border-radius: 48% 52% 52% 48% / 49.5% 50.5% 52% 48%;
      }
      60% {
        border-radius: 49% 51% 48.5% 51.5% / 52% 48% 51% 49%;
      }
      70% {
        border-radius: 51.5% 48.5% 47% 53% / 53% 47% 49.5% 50.5%;
      }
      80% {
        border-radius: 53% 47% 49% 51% / 50.5% 49.5% 48% 52%;
      }
      90% {
        border-radius: 52% 48% 51.5% 48.5% / 48.5% 51.5% 50% 50%;
      }
      100% {
        border-radius: 51% 49% 48% 52% / 52% 47% 53% 48%;
      }
    }

    /* Bardziej realistyczny float-main z nieregularnymi ruchami i delikatną rotacją */
    @keyframes float-main {
      0% {
        transform: translate(-50%, -50%) translateY(0) rotate(0deg);
      }
      15% {
        transform: translate(-51.5%, -49%) translateY(-3px) rotate(0.5deg);
      }
      30% {
        transform: translate(-52%, -51%) translateY(-7px) rotate(0.2deg);
      }
      45% {
        transform: translate(-50.5%, -52%) translateY(-9px) rotate(-0.3deg);
      }
      60% {
        transform: translate(-49%, -51%) translateY(-7px) rotate(-0.7deg);
      }
      75% {
        transform: translate(-48.5%, -50%) translateY(-4px) rotate(-0.4deg);
      }
      90% {
        transform: translate(-49%, -49%) translateY(-1px) rotate(0.2deg);
      }
      100% {
        transform: translate(-50%, -50%) translateY(0) rotate(0deg);
      }
    }

    /* Ulepszony float-redirect z bardziej płynnym, nielinearnym ruchem */
    @keyframes float-redirect {
      0% {
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        filter: brightness(1);
      }
      20% {
        transform: translate(-48.5%, -51.5%) scale(1.01) translateY(-4px) rotate(0.7deg);
        filter: brightness(1.02);
      }
      40% {
        transform: translate(-51%, -49.5%) scale(0.99) translateY(-8px) rotate(0.3deg);
        filter: brightness(1.03);
      }
      60% {
        transform: translate(-52.5%, -50.5%) scale(1.01) translateY(-10px) rotate(-0.5deg);
        filter: brightness(1.02);
      }
      80% {
        transform: translate(-50%, -52%) scale(1.02) translateY(-6px) rotate(-0.8deg);
        filter: brightness(1.01);
      }
      100% {
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        filter: brightness(1);
      }
    }

    /* Bardziej subtelne i płynne float-main-after */
    @keyframes float-main-after {
      0% {
        transform: translate(-50%, -50%) scale(0.9) rotate(0deg);
        filter: brightness(1);
      }
      20% {
        transform: translate(-51.5%, -51%) scale(0.905) translateY(-5px) rotate(0.4deg);
        filter: brightness(0.98);
      }
      40% {
        transform: translate(-52%, -49.5%) scale(0.895) translateY(-9px) rotate(0.2deg);
        filter: brightness(0.97);
      }
      60% {
        transform: translate(-50.5%, -48%) scale(0.91) translateY(-12px) rotate(-0.3deg);
        filter: brightness(0.98);
      }
      80% {
        transform: translate(-48.5%, -49%) scale(0.905) translateY(-7px) rotate(-0.5deg);
        filter: brightness(0.99);
      }
      100% {
        transform: translate(-50%, -50%) scale(0.9) rotate(0deg);
        filter: brightness(1);
      }
    }

    /* Bardziej realistyczne mainBubbleDeform z lepszą fizyką */
    @keyframes mainBubbleDeform {
      0% {
        transform: translate(-50%, -50%) scale(1);
        border-radius: 51% 49% 48% 52% / 52% 47% 53% 48%;
        filter: brightness(1);
      }
      5% {
        transform: translate(-51%, -50.5%) scale(1.01, 0.995);
        border-radius: 52% 48% 47% 53% / 50% 50% 53% 47%;
        filter: brightness(1.01);
      }
      10% {
        transform: translate(-52%, -50.2%) scale(1.025, 0.987);
        border-radius: 53% 47% 46% 54% / 50% 49% 54% 46%;
        filter: brightness(1.02);
      }
      15% {
        transform: translate(-53%, -50%) scale(1.035, 0.975);
        border-radius: 54% 46% 45% 55% / 49% 47% 56% 45%;
        filter: brightness(1.03);
      }
      20% {
        transform: translate(-54%, -49.7%) scale(1.04, 0.965);
        border-radius: 55% 45% 43% 57% / 47% 45% 58% 44%;
        filter: brightness(1.04);
      }
      25% {
        transform: translate(-55%, -49.5%) scale(1.045, 0.96);
        border-radius: 53% 47% 41% 59% / 45% 43% 60% 42%;
        filter: brightness(1.03);
      }
      30% {
        transform: translate(-56%, -49.8%) scale(1.05, 0.958);
        border-radius: 51% 49% 40% 60% / 43% 41% 62% 40%;
        filter: brightness(1.02);
      }
      35% {
        transform: translate(-57%, -50%) scale(1.055, 0.952);
        border-radius: 48% 52% 38% 62% / 40% 39% 64% 38%;
        filter: brightness(1.01);
      }
      40% {
        transform: translate(-58%, -50.2%) scale(1.06, 0.945);
        border-radius: 45% 55% 36% 64% / 38% 36% 66% 36%;
        filter: brightness(1);
      }
      45% {
        transform: translate(-59%, -50.5%) scale(1.058, 0.942);
        border-radius: 42% 58% 34% 66% / 35% 33% 68% 34%;
        filter: brightness(0.99);
      }
      50% {
        transform: translate(-60%, -50.7%) scale(1.055, 0.94);
        border-radius: 38% 62% 32% 68% / 33% 30% 70% 32%;
        filter: brightness(0.98);
      }
      55% {
        transform: translate(-58%, -50.5%) scale(1.03, 0.965);
        border-radius: 40% 60% 37% 63% / 38% 36% 64% 37%;
        filter: brightness(0.97);
      }
      60% {
        transform: translate(-56.5%, -50.3%) scale(0.99, 0.98);
        border-radius: 43% 57% 41% 59% / 42% 40% 60% 41%;
        filter: brightness(0.96);
      }
      65% {
        transform: translate(-55%, -50.1%) scale(0.97, 0.995);
        border-radius: 45% 55% 45% 55% / 46% 44% 56% 45%;
        filter: brightness(0.95);
      }
      70% {
        transform: translate(-54%, -50%) scale(0.95, 1.01);
        border-radius: 47% 53% 48% 52% / 48% 47% 53% 48%;
        filter: brightness(0.94);
      }
      75% {
        transform: translate(-53%, -49.8%) scale(0.935, 1.02);
        border-radius: 48% 52% 49% 51% / 50% 49% 51% 49%;
        filter: brightness(0.935);
      }
      80% {
        transform: translate(-52%, -49.7%) scale(0.925, 1.025);
        border-radius: 49% 51% 50% 50% / 51% 50% 50% 50%;
        filter: brightness(0.93);
      }
      85% {
        transform: translate(-51.5%, -49.9%) scale(0.915, 1.02);
        border-radius: 50% 50% 50.5% 49.5% / 51.5% 52% 48% 49%;
        filter: brightness(0.92);
      }
      90% {
        transform: translate(-51%, -50%) scale(0.907, 1.015);
        border-radius: 50.5% 49.5% 51% 49% / 52% 52.5% 47.5% 48.5%;
        filter: brightness(0.91);
      }
      95% {
        transform: translate(-50.5%, -50.1%) scale(0.903, 1.005);
        border-radius: 50.7% 49.3% 51.5% 48.5% / 51.5% 52% 48% 49%;
        filter: brightness(0.905);
      }
      100% {
        transform: translate(-50%, -50%) scale(0.9);
        border-radius: 51% 49% 52% 48% / 50% 51% 49% 50%;
        filter: brightness(0.9);
      }
    }

    /* Bardziej realistyczne newBubbleForm z lepszą fizyką formowania */
    @keyframes newBubbleForm {
      0% {
        opacity: 0;
        transform: translate(-150%, -50%) scale(0.05);
        border-radius: 45% 55% 50% 50% / 50% 50% 45% 55%;
        filter: brightness(1.2);
      }
      5% {
        opacity: 0.05;
        transform: translate(-145%, -52%) scale(0.12);
        border-radius: 47% 53% 49% 51% / 51% 49% 47% 53%;
        filter: brightness(1.18);
      }
      10% {
        opacity: 0.1;
        transform: translate(-140%, -53%) scale(0.18);
        border-radius: 49% 51% 48% 52% / 52% 48% 49% 51%;
        filter: brightness(1.16);
      }
      15% {
        opacity: 0.18;
        transform: translate(-135%, -51%) scale(0.24);
        border-radius: 50% 50% 47% 53% / 53% 47% 50% 50%;
        filter: brightness(1.14);
      }
      20% {
        opacity: 0.25;
        transform: translate(-130%, -49%) scale(0.3);
        border-radius: 52% 48% 46% 54% / 54% 46% 51% 49%;
        filter: brightness(1.12);
      }
      25% {
        opacity: 0.32;
        transform: translate(-125%, -48%) scale(0.35);
        border-radius: 53% 47% 45% 55% / 55% 45% 52% 48%;
        filter: brightness(1.10);
      }
      30% {
        opacity: 0.4;
        transform: translate(-120%, -47.5%) scale(0.4);
        border-radius: 54% 46% 44% 56% / 56% 44% 53% 47%;
        filter: brightness(1.08);
      }
      35% {
        opacity: 0.48;
        transform: translate(-115%, -47.8%) scale(0.45);
        border-radius: 53% 47% 45% 55% / 54% 46% 52% 48%;
        filter: brightness(1.06);
      }
      40% {
        opacity: 0.56;
        transform: translate(-110%, -48.2%) scale(0.5);
        border-radius: 52% 48% 46% 54% / 53% 47% 51% 49%;
        filter: brightness(1.04);
      }
      45% {
        opacity: 0.64;
        transform: translate(-105%, -48.8%) scale(0.57, 0.54);
        border-radius: 51% 49% 47% 53% / 52% 48% 50% 50%;
        filter: brightness(1.03);
      }
      50% {
        opacity: 0.72;
        transform: translate(-100%, -49.5%) scale(0.63, 0.59);
        border-radius: 50% 50% 48% 52% / 51% 49% 49% 51%;
        filter: brightness(1.02);
      }
      55% {
        opacity: 0.78;
        transform: translate(-95%, -50%) scale(0.69, 0.65);
        border-radius: 49% 51% 49% 51% / 50% 50% 48% 52%;
        filter: brightness(1.01);
      }
      60% {
        opacity: 0.84;
        transform: translate(-90%, -50.5%) scale(0.75, 0.72);
        border-radius: 48% 52% 50% 50% / 49% 51% 48% 52%;
        filter: brightness(1);
      }
      65% {
        opacity: 0.88;
        transform: translate(-85%, -51%) scale(0.8, 0.78);
        border-radius: 49% 51% 51% 49% / 48% 52% 49% 51%;
        filter: brightness(1.01);
      }
      70% {
        opacity: 0.91;
        transform: translate(-80%, -51.5%) scale(0.85, 0.83);
        border-radius: 50% 50% 52% 48% / 47% 53% 50% 50%;
        filter: brightness(1.02);
      }
      75% {
        opacity: 0.94;
        transform: translate(-75%, -51.8%) scale(0.89, 0.87);
        border-radius: 51% 49% 53% 47% / 48% 52% 51% 49%;
        filter: brightness(1.03);
      }
      80% {
        opacity: 0.96;
        transform: translate(-70%, -52%) scale(0.92, 0.9);
        border-radius: 52% 48% 53% 47% / 49% 51% 52% 48%;
        filter: brightness(1.04);
      }
      85% {
        opacity: 0.97;
        transform: translate(-65%, -51.5%) scale(0.95, 0.93);
        border-radius: 53% 47% 52% 48% / 50% 50% 52.5% 47.5%;
        filter: brightness(1.03);
      }
      90% {
        opacity: 0.98;
        transform: translate(-60%, -51%) scale(0.97, 0.96);
        border-radius: 52.5% 47.5% 51.5% 48.5% / 51% 49% 52% 48%;
        filter: brightness(1.02);
      }
      95% {
        opacity: 0.99;
        transform: translate(-55%, -50.5%) scale(0.99, 0.98);
        border-radius: 52% 48% 51% 49% / 51.5% 48.5% 51.5% 48.5%;
        filter: brightness(1.01);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        border-radius: 51.5% 48.5% 50.5% 49.5% / 52% 48% 51% 49%;
        filter: brightness(1);
      }
    }

    /* Bardziej realistyczne connectorAnimation z lepszą fizyką płynu */
    @keyframes connectorAnimation {
      0% {
        opacity: 0;
        width: 0;
        height: 0;
        transform: scaleX(0) translateX(0);
        border-radius: 50%;
        filter: brightness(1);
      }
      /* Formowanie */
      5% {
        opacity: 0.2;
        width: 10px;
        height: 8px;
        transform: scaleX(0.1) translateX(5px);
        border-radius: 48% 52% 49% 51% / 51% 49% 50% 50%;
        filter: brightness(1.05);
      }
      10% {
        opacity: 0.35;
        width: 16px;
        height: 13px;
        transform: scaleX(0.18) translateX(9px);
        border-radius: 46% 54% 48% 52% / 52% 48% 49% 51%;
        filter: brightness(1.08);
      }
      15% {
        opacity: 0.45;
        width: 22px;
        height: 17px;
        transform: scaleX(0.25) translateX(14px);
        border-radius: 44% 56% 47% 53% / 53% 47% 48% 52%;
        filter: brightness(1.1);
      }
      /* Wydłużenie */
      20% {
        opacity: 0.55;
        width: 28px;
        height: 20px;
        transform: scaleX(0.32) translateX(18px);
        border-radius: 42% 58% 46% 54% / 54% 46% 47% 53%;
        filter: brightness(1.12);
      }
      25% {
        opacity: 0.65;
        width: 34px;
        height: 22px;
        transform: scaleX(0.4) translateX(23px) skewX(-2deg);
        border-radius: 40% 60% 45% 55% / 55% 45% 46% 54%;
        filter: brightness(1.1);
      }
      30% {
        opacity: 0.75;
        width: 39px;
        height: 24px;
        transform: scaleX(0.48) translateX(27px) skewX(-3deg);
        border-radius: 38% 62% 43% 57% / 56% 44% 45% 55%;
        filter: brightness(1.08);
      }
      35% {
        opacity: 0.85;
        width: 43px;
        height: 26px;
        transform: scaleX(0.55) translateX(32px) skewX(-4deg);
        border-radius: 36% 64% 42% 58% / 57% 43% 44% 56%;
        filter: brightness(1.06);
      }
      /* Maksymalne rozciągnięcie */
      40% {
        opacity: 0.9;
        width: 47px;
        height: 28px;
        transform: scaleX(0.62) translateX(36px) skewX(-3.5deg);
        border-radius: 35% 65% 40% 60% / 58% 42% 43% 57%;
        filter: brightness(1.04);
      }
      45% {
        opacity: 0.95;
        width: 50px;
        height: 30px;
        transform: scaleX(0.68) translateX(40px) skewX(-3deg);
        border-radius: 33% 67% 38% 62% / 59% 41% 42% 58%;
        filter: brightness(1.02);
      }
      50% {
        opacity: 1;
        width: 52px;
        height: 30px;
        transform: scaleX(0.72) translateX(43px) skewX(-2deg);
        border-radius: 32% 68% 36% 64% / 60% 40% 41% 59%;
        filter: brightness(1);
      }
      /* Zwężanie się w środku - fizyka cieczy */
      53% {
        opacity: 0.98;
        width: 50px;
        height: 28px;
        transform: scaleX(0.69) translateX(45px) skewX(-1.5deg);
        border-radius: 33% 67% 35% 65% / 59% 41% 40% 60%;
        filter: brightness(0.99);
        box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.4),
                    0 0 5px rgba(0, 112, 243, 0.3);
      }
      56% {
        opacity: 0.96;
        width: 48px;
        height: 27px;
        transform: scaleX(0.65) translateX(48px) skewX(-1deg);
        border-radius: 34% 66% 34% 66% / 58% 42% 39% 61%;
        filter: brightness(0.98);
        box-shadow: inset 0 0 7px rgba(255, 255, 255, 0.35),
                    0 0 4px rgba(0, 112, 243, 0.25);
      }
      59% {
        opacity: 0.94;
        width: 45px;
        height: 25px;
        transform: scaleX(0.62) translateX(51px) skewX(-0.5deg);
        border-radius: 36% 64% 33% 67% / 57% 43% 38% 62%;
        filter: brightness(0.97);
        box-shadow: inset 0 0 6px rgba(255, 255, 255, 0.3),
                    0 0 4px rgba(0, 112, 243, 0.2);
      }
      62% {
        opacity: 0.92;
        width: 42px;
        height: 24px;
        transform: scaleX(0.58) translateX(54px);
        border-radius: 38% 62% 32% 68% / 56% 44% 37% 63%;
        filter: brightness(0.96);
        box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.25),
                    0 0 3px rgba(0, 112, 243, 0.18);
      }
      /* Bardziej zauważalne zwężenie */
      65% {
        opacity: 0.9;
        width: 38px;
        height: 22px;
        transform: scaleX(0.54) translateX(57px);
        border-radius: 40% 60% 31% 69% / 55% 45% 36% 64%;
        filter: brightness(0.95);
        box-shadow: inset 0 0 4px rgba(255, 255, 255, 0.2),
                    0 0 3px rgba(0, 112, 243, 0.15);
      }
      68% {
        opacity: 0.85;
        width: 34px;
        height: 20px;
        transform: scaleX(0.5) translateX(60px);
        border-radius: 42% 58% 30% 70% / 54% 46% 35% 65%;
        filter: brightness(0.94);
        box-shadow: inset 0 0 3px rgba(255, 255, 255, 0.18),
                    0 0 2px rgba(0, 112, 243, 0.12);
      }
      71% {
        opacity: 0.8;
        width: 30px;
        height: 18px;
        transform: scaleX(0.45) translateX(64px);
        border-radius: 44% 56% 28% 72% / 52% 48% 34% 66%;
        filter: brightness(0.93);
        box-shadow: inset 0 0 3px rgba(255, 255, 255, 0.15),
                    0 0 2px rgba(0, 112, 243, 0.1);
      }
      /* Krytyczne zwężenie przed zerwaniem */
      74% {
        opacity: 0.75;
        width: 25px;
        height: 16px;
        transform: scaleX(0.4) translateX(67px);
        border-radius: 46% 54% 26% 74% / 50% 50% 32% 68%;
        filter: brightness(0.92);
        box-shadow: inset 0 0 2px rgba(255, 255, 255, 0.12),
                    0 0 1px rgba(0, 112, 243, 0.08);
      }
      77% {
        opacity: 0.65;
        width: 20px;
        height: 12px;
        transform: scaleX(0.32) translateX(71px);
        border-radius: 48% 52% 24% 76% / 48% 52% 30% 70%;
        filter: brightness(0.91);
        box-shadow: inset 0 0 1px rgba(255, 255, 255, 0.1),
                    0 0 1px rgba(0, 112, 243, 0.05);
      }
      /* Zrywanie - łącznik tuż przed separacją */
      80% {
        opacity: 0.55;
        width: 15px;
        height: 8px;
        transform: scaleX(0.25) translateX(75px);
        border-radius: 49% 51% 22% 78% / 47% 53% 28% 72%;
        filter: brightness(0.9);
      }
      83% {
        opacity: 0.45;
        width: 10px;
        height: 6px;
        transform: scaleX(0.18) translateX(80px);
        border-radius: 50% 50% 20% 80% / 46% 54% 26% 74%;
        filter: brightness(0.89);
      }
      86% {
        opacity: 0.35;
        width: 7px;
        height: 4px;
        transform: scaleX(0.12) translateX(85px);
        border-radius: 50% 50% 18% 82% / 45% 55% 24% 76%;
        filter: brightness(0.88);
      }
      /* Zanikanie po zerwaniu */
      89% {
        opacity: 0.25;
        width: 5px;
        height: 3px;
        transform: scaleX(0.08) translateX(90px);
        border-radius: 50% 50% 20% 80% / 46% 54% 25% 75%;
        filter: brightness(0.89);
      }
      92% {
        opacity: 0.18;
        width: 4px;
        height: 2px;
        transform: scaleX(0.06) translateX(94px);
        border-radius: 50% 50% 30% 70% / 47% 53% 30% 70%;
        filter: brightness(0.9);
      }
      95% {
        opacity: 0.1;
        width: 3px;
        height: 2px;
        transform: scaleX(0.04) translateX(97px);
        border-radius: 50% 50% 40% 60% / 48% 52% 40% 60%;
        filter: brightness(0.95);
      }
      100% {
        opacity: 0;
        width: 0;
        height: 0;
        transform: scaleX(0) translateX(100px);
        border-radius: 50%;
        filter: brightness(1);
      }
    }

    /* Bardziej realistyczne tinyBubbleRise z lepszą fizyką */
    @keyframes tinyBubbleRise {
      0% {
        opacity: 0;
        transform: translate(0, 0) scale(0) rotate(0deg);
        filter: brightness(1);
      }
      10% {
        opacity: 1;
        transform: translate(calc(var(--tx) * 0.12), calc(var(--ty) * 0.08)) scale(1) rotate(calc(var(--tr) * 0.1));
        filter: brightness(1.1);
      }
      20% {
        opacity: 0.98;
        transform: translate(calc(var(--tx) * 0.25 + var(--wobble-x) * 0.3), calc(var(--ty) * 0.18)) scale(0.98) 
                  rotate(calc(var(--tr) * 0.25));
        filter: brightness(1.08);
      }
      30% {
        opacity: 0.95;
        transform: translate(calc(var(--tx) * 0.37 - var(--wobble-x) * 0.5), calc(var(--ty) * 0.32)) scale(0.96) 
                  rotate(calc(var(--tr) * 0.38));
        filter: brightness(1.06);
      }
      40% {
        opacity: 0.9;
        transform: translate(calc(var(--tx) * 0.5 + var(--wobble-x) * 0.7), calc(var(--ty) * 0.48)) scale(0.94) 
                  rotate(calc(var(--tr) * 0.5));
        filter: brightness(1.04);
      }
      50% {
        opacity: 0.85;
        transform: translate(calc(var(--tx) * 0.63 - var(--wobble-x) * 0.4), calc(var(--ty) * 0.65)) scale(0.92) 
                  rotate(calc(var(--tr) * 0.63));
        filter: brightness(1.03);
      }
      60% {
        opacity: 0.8;
        transform: translate(calc(var(--tx) * 0.74 + var(--wobble-x) * 0.2), calc(var(--ty) * 0.77)) scale(0.89) 
                  rotate(calc(var(--tr) * 0.75));
        filter: brightness(1.02);
      }
      70% {
        opacity: 0.7;
        transform: translate(calc(var(--tx) * 0.83 - var(--wobble-x) * 0.1), calc(var(--ty) * 0.85)) scale(0.85) 
                  rotate(calc(var(--tr) * 0.87));
        filter: brightness(1.01);
      }
      80% {
        opacity: 0.5;
        transform: translate(calc(var(--tx) * 0.91 + var(--wobble-x) * 0.07), calc(var(--ty) * 0.91)) scale(0.8) 
                  rotate(calc(var(--tr) * 0.93));
        filter: brightness(1);
      }
      90% {
        opacity: 0.25;
        transform: translate(calc(var(--tx) * 0.96 - var(--wobble-x) * 0.03), calc(var(--ty) * 0.96)) scale(0.75) 
                  rotate(calc(var(--tr) * 0.97));
        filter: brightness(0.98);
      }
      100% {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(0.7) rotate(var(--tr));
        filter: brightness(0.95);
      }
    }

    /* Nowa animacja dla drgań powierzchni bąbelka */
    @keyframes bubble-surface-tension {
      0% {
        box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.4),
                    0 0 15px rgba(0, 112, 243, 0.3);
      }
      25% {
        box-shadow: inset 0 0 22px rgba(255, 255, 255, 0.45),
                    0 0 16px rgba(0, 112, 243, 0.32);
      }
      50% {
        box-shadow: inset 0 0 25px rgba(255, 255, 255, 0.5),
                    0 0 18px rgba(0, 112, 243, 0.35);
      }
      75% {
        box-shadow: inset 0 0 22px rgba(255, 255, 255, 0.45),
                    0 0 16px rgba(0, 112, 243, 0.32);
      }
      100% {
        box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.4),
                    0 0 15px rgba(0, 112, 243, 0.3);
      }
    }

    /* Dodatkowa animacja dla powstających mikrobąbelków przy rozdzielaniu */
    @keyframes micro-bubble-form {
      0% {
        opacity: 0;
        transform: scale(0);
        filter: brightness(1.2);
      }
      20% {
        opacity: 0.8;
        transform: scale(1.2);
        filter: brightness(1.1);
      }
      40% {
        opacity: 1;
        transform: scale(1);
        filter: brightness(1);
      }
      80% {
        opacity: 0.6;
        transform: scale(0.5);
        filter: brightness(0.9);
      }
      100% {
        opacity: 0;
        transform: scale(0);
        filter: brightness(0.8);
      }
    }

    /* Animacja pulsowania dla łącznika podczas rozciągania */
    @keyframes pulseConnector {
      0%, 100% {
        box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.5),
                    0 0 10px rgba(0, 112, 243, 0.1);
      }
      50% {
        box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.7),
                    0 0 15px rgba(0, 112, 243, 0.2);
      }
    }

    /* Ulepszenie animacji highlight */
    @keyframes pulse-highlight {
      0% {
        opacity: 0.65;
        transform: rotate(-15deg) scale(1) translate(0, 0);
        filter: blur(2px);
      }
      25% {
        opacity: 0.75;
        transform: rotate(-14deg) scale(1.03) translate(1px, -1px);
        filter: blur(1.8px);
      }
      50% {
        opacity: 0.85;
        transform: rotate(-12deg) scale(1.05) translate(2px, -2px);
        filter: blur(1.5px);
      }
      75% {
        opacity: 0.75;
        transform: rotate(-13deg) scale(1.03) translate(1px, -1px);
        filter: blur(1.8px);
      }
      100% {
        opacity: 0.65;
        transform: rotate(-15deg) scale(1) translate(0, 0);
        filter: blur(2px);
      }
    }
    
    /* Spin animation for loader */
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    
    /* Text pulsing */
    @keyframes text-pulse {
      0% {
        transform: translateX(-50%) scale(1);
      }
      100% {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }
    }
    
    /* Particles floating */
    @keyframes float-particle {
      0%, 100% {
        transform: translate(0, 0);
      }
      25% {
        transform: translate(var(--x-offset), var(--y-offset));
      }
      50% {
        transform: translate(calc(var(--x-offset) * 0.3), calc(var(--y-offset) * -0.8));
      }
      75% {
        transform: translate(calc(var(--x-offset) * -0.5), calc(var(--y-offset) * 0.3));
      }
    }
    
    /* Reduced motion preferences */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body>
  <!-- Theme Toggle Button -->
  <button class="theme-toggle" id="themeToggle" aria-label="Toggle dark mode">
    <i class="fas fa-moon" id="themeIcon"></i>
  </button>

  <!-- Background Gradient -->
  <div class="bg-gradient"></div>

  <!-- Background Particles -->
  <div class="particles-container" id="particlesContainer"></div>

  <!-- Main Bubble Container -->
  <div class="bubble-container" id="bubbleContainer">
    <!-- Main Bubble -->
    <div class="bubble main-bubble" id="mainBubble">
      <div class="highlight highlight-main"></div>
      <div class="highlight highlight-small"></div>
      <div class="spinner"></div>
    </div>
    
    <!-- Redirect Bubble -->
    <div class="bubble redirect-bubble" id="redirectBubble">
      <div class="highlight highlight-main"></div>
      <div class="highlight highlight-small"></div>
      <div class="arrow"></div>
    </div>
    
    <!-- Bubble Connector -->
    <div class="bubble-connector" id="bubbleConnector"></div>
  </div>

  <!-- Loading Text -->
  <div class="loading-text" id="loadingText">
    Przekierowywanie...
  </div>

  <!-- Font Awesome -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
  
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Configuration
      const redirectUrl = "https://guziczak.github.io/lukasz/";
      const autoRedirectDelay = 5000;  // ms before auto-redirect
      const splitStartDelay = 1;    // ms before bubble split animation starts
      const splitDuration = 1000;     // ms for the split animation
      
      // Get DOM elements
      const bubbleContainer = document.getElementById('bubbleContainer');
      const mainBubble = document.getElementById('mainBubble');
      const redirectBubble = document.getElementById('redirectBubble');
      const bubbleConnector = document.getElementById('bubbleConnector');
      const themeToggle = document.getElementById('themeToggle');
      const loadingText = document.getElementById('loadingText');
      const particlesContainer = document.getElementById('particlesContainer');
      
      // Initialize theme based on user preference
      initTheme();
      
      // Create background particles
      createBackgroundParticles();
      
      // Redirect on click
      redirectBubble.addEventListener('click', () => {
        window.location.href = redirectUrl;
      });
      
      // Toggle theme
      themeToggle.addEventListener('click', toggleDarkMode);
      
      // Schedule the bubble split animation
      setTimeout(startBubbleSeparationAnimation, splitStartDelay);
      
      // Schedule auto-redirect (ensure this always happens regardless of localStorage or other issues)
      setTimeout(() => {
        // Fade out loading text before redirect
        if (loadingText) loadingText.classList.add('fade-out');
        
        setTimeout(() => {
          window.location.href = redirectUrl;
        }, 500);
      }, autoRedirectDelay);
      
      // Funkcja inicjalizacji motywu
      function initTheme() {
        let isDarkMode = false;
        
        try {
          // Sprawdź preferencje przeglądarki najpierw
          const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
          
          // Następnie spróbuj wczytać zapisane preferencje
          try {
            const savedTheme = localStorage.getItem('darkMode');
            isDarkMode = savedTheme === 'true' || (savedTheme === null && prefersDarkMode);
          } catch (storageError) {
            isDarkMode = prefersDarkMode;
          }
        } catch (error) {
          isDarkMode = false;
        }
        
        // Zastosuj motyw natychmiast
        if (isDarkMode) {
          document.body.classList.add('dark-mode');
        }
        
        // Upewnij się, że ikona jest zaktualizowana po załadowaniu Font Awesome
        // Używamy timeout, aby dać czas na załadowanie Font Awesome
        setTimeout(() => {
          updateThemeIcon(isDarkMode);
        }, 100);
      }
      
      // Funkcja aktualizacji ikony
      function updateThemeIcon(isDarkMode) {
        const themeIcon = document.getElementById('themeIcon');
        if (!themeIcon) return;
        
        // Najpierw usuń wszystkie klasy ikon (zarówno księżyc jak i słońce)
        themeIcon.classList.remove('fa-moon');
        themeIcon.classList.remove('fa-sun');
        
        // Dodaj właściwą klasę w zależności od bieżącego motywu
        if (isDarkMode) {
          themeIcon.classList.add('fa-sun'); // W trybie ciemnym pokazujemy słońce (aby przełączyć na jasny)
        } else {
          themeIcon.classList.add('fa-moon'); // W trybie jasnym pokazujemy księżyc (aby przełączyć na ciemny)
        }
      }
      
      // Funkcja przełączania trybu ciemnego
      function toggleDarkMode() {
        const isDark = document.body.classList.toggle('dark-mode');
        
        // Upewnij się, że ikona jest natychmiast zaktualizowana
        updateThemeIcon(isDark);
        
        // Zapisz preferencje
        try {
          localStorage.setItem('darkMode', isDark);
        } catch (error) {
          console.warn("Nie można zapisać preferencji motywu w localStorage", error);
        }
      }
      
      // Create floating background particles
      function createBackgroundParticles() {
        if (!particlesContainer) return;
        
        for (let i = 0; i < 20; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          
          // Random size between 3px and 12px
          const size = 3 + Math.random() * 9;
          particle.style.width = `${size}px`;
          particle.style.height = `${size}px`;
          
          // Random position
          const left = Math.random() * 100;
          const top = Math.random() * 100;
          particle.style.left = `${left}%`;
          particle.style.top = `${top}%`;
          
          // Random animation properties
          particle.style.setProperty('--x-offset', `${Math.random() * 100 - 50}px`);
          particle.style.setProperty('--y-offset', `${Math.random() * 100 - 50}px`);
          
          // Random animation delay
          particle.style.animationDelay = `${Math.random() * 5}s`;
          
          particlesContainer.appendChild(particle);
        }
      }
      
      // Główna funkcja uruchamiająca animację separacji bąbelków
      function startBubbleSeparationAnimation() {
        // Ustawienie łącznika bąbelków
        try {
          const mainRect = mainBubble.getBoundingClientRect();
          const containerRect = bubbleContainer.getBoundingClientRect();
          
          const mainCenterX = mainRect.left - containerRect.left + mainRect.width / 2;
          const mainCenterY = mainRect.top - containerRect.top + mainRect.height / 2;
          
          bubbleConnector.style.left = `${mainCenterX}px`;
          bubbleConnector.style.top = `${mainCenterY}px`;
          
          // Dodaj animację pulsowania do łącznika
          bubbleConnector.style.animation = 'pulseConnector 1s infinite alternate ease-in-out';
        } catch (error) {
          console.warn("Błąd podczas ustawiania łącznika bąbelków, kontynuacja animacji", error);
        }
        
        setTimeout(() => {
          // Rozpocznij animacje deformacji głównego bąbelka i formowania nowego
          if (mainBubble) {
            mainBubble.style.animation = `mainBubbleDeform ${splitDuration}ms forwards cubic-bezier(0.34, 1.56, 0.64, 1)`;
          }
          
          if (redirectBubble) {
            redirectBubble.style.animation = `newBubbleForm ${splitDuration}ms forwards cubic-bezier(0.34, 1.56, 0.64, 1)`;
          }
          
          if (bubbleConnector) {
            bubbleConnector.style.animation = `connectorAnimation ${splitDuration}ms forwards cubic-bezier(0.34, 1.56, 0.64, 1)`;
          }
          
          // Stwórz małe bąbelki w dokładnym momencie separacji
          setTimeout(() => {
            try {
              createTinyBubbleEffect();
            } catch (error) {
              console.warn("Błąd podczas tworzenia efektu małych bąbelków, kontynuacja animacji", error);
            }
          }, splitDuration * 0.48); // Tworzenie bąbelków w dokładnym momencie separacji
          
          // Po zakończeniu separacji
          setTimeout(() => {
            // Użyj klas zamiast styli inline, aby upewnić się, że bąbelki pozostają widoczne
            if (mainBubble) mainBubble.classList.add('main-floating');
            if (redirectBubble) redirectBubble.classList.add('redirect-floating');
            
            // Aktualizuj tekst ładowania
            if (loadingText) {
              loadingText.textContent = 'Kliknij bąbelek, aby przejść dalej';
              loadingText.classList.add('pulse');
            }
            
            // Dodaj efekty po separacji
            try {
              addPostSeparationEffects();
            } catch (error) {
              console.warn("Błąd podczas dodawania efektów po separacji, kontynuacja animacji", error);
            }
          }, splitDuration + 100);
        }, 300);
      }
      
      // Funkcja tworząca małe bąbelki podczas separacji
      function createTinyBubbleEffect() {
        if (!mainBubble || !redirectBubble || !bubbleContainer) return;
        
        try {
          const mainRect = mainBubble.getBoundingClientRect();
          const redirectRect = redirectBubble.getBoundingClientRect();
          const containerRect = bubbleContainer.getBoundingClientRect();
          
          // Obliczanie punktu separacji między bąbelkami
          const mainCenterX = mainRect.left - containerRect.left + mainRect.width / 2;
          const mainCenterY = mainRect.top - containerRect.top + mainRect.height / 2;
          const redirectCenterX = redirectRect.left - containerRect.left + redirectRect.width / 2;
          const redirectCenterY = redirectRect.top - containerRect.top + redirectRect.height / 2;
          
          // Obliczanie dokładnego punktu przerwania
          const breakPointX = mainCenterX + (redirectCenterX - mainCenterX) * 0.42; // Przesunięte bliżej głównego bąbelka
          const breakPointY = mainCenterY + (redirectCenterY - mainCenterY) * 0.38; // Przesunięte nieco w dół
          
          // Wektor kierunku przerwania
          const breakAngle = Math.atan2(redirectCenterY - mainCenterY, redirectCenterX - mainCenterX);
          
          // Symulacja trójfazowego oddzielania się bąbelków
          const numMicroBubbles = 5 + Math.floor(Math.random() * 4); // Mikrobąbelki w momencie przerwania
          const numFirstWave = 10 + Math.floor(Math.random() * 6); // Pierwsza fala
          const numSecondWave = 8 + Math.floor(Math.random() * 5); // Druga fala
          const numThirdWave = 5 + Math.floor(Math.random() * 3); // Trzecia fala (mniejsza)
          
          // Mikrobąbelki w momencie przerwania (bardzo małe i szybkie)
          createMicroBubbles(numMicroBubbles, breakPointX, breakPointY, breakAngle);
          
          // Pierwsza fala - bąbelki tuż po przerwaniu
          createBubbleWave(numFirstWave, breakPointX, breakPointY, breakAngle, 0, 0.2);
          
          // Druga fala - opóźnione bąbelki (większe)
          setTimeout(() => {
            createBubbleWave(numSecondWave, breakPointX, breakPointY, breakAngle, 0.7, 0.5);
          }, 120);
          
          // Trzecia fala - jeszcze bardziej opóźnione bąbelki (najmniejsze, powolne)
          setTimeout(() => {
            createBubbleWave(numThirdWave, breakPointX, breakPointY, breakAngle, 1.2, 0.8);
          }, 250);
          
        } catch (error) {
          console.warn("Błąd podczas obliczania pozycji efektu bąbelków", error);
        }
      }

      // Funkcja tworząca mikrobąbelki (bardzo małe, krótkotrwałe)
      function createMicroBubbles(count, originX, originY, angle) {
        for (let i = 0; i < count; i++) {
          try {
            const microBubble = document.createElement('div');
            microBubble.className = 'tiny-bubble';
            
            // Styl dla mikrobąbelków
            microBubble.style.background = 'rgba(0, 112, 243, 0.2)';
            microBubble.style.boxShadow = 'inset 0 0 3px rgba(255, 255, 255, 0.8), 0 0 4px rgba(0, 112, 243, 0.2)';
            
            // Losowy rozmiar (bardzo małe)
            const size = 1 + Math.random() * 2;
            microBubble.style.width = `${size}px`;
            microBubble.style.height = `${size}px`;
            
            // Początkowa pozycja - dokładnie w punkcie przerwania
            const radialDistance = Math.random() * 4; // Bardzo małe rozproszenie początkowe
            const radialAngle = angle + (Math.random() - 0.5) * Math.PI * 0.3; // Węższy stożek rozproszenia
            
            const offsetX = Math.cos(radialAngle) * radialDistance;
            const offsetY = Math.sin(radialAngle) * radialDistance;
            
            microBubble.style.left = `${originX + offsetX}px`;
            microBubble.style.top = `${originY + offsetY}px`;
            
            // Kalkulacja trajektorii - bardzo szybkie rozproszenie
            const dispersalAngle = angle + (Math.random() - 0.5) * Math.PI * 0.5;
            const distance = 15 + Math.random() * 25; // Krótszy dystans
            
            // Zapisz parametry animacji jako zmienne CSS
            microBubble.style.setProperty('--tx', `${Math.cos(dispersalAngle) * distance}px`);
            microBubble.style.setProperty('--ty', `${Math.sin(dispersalAngle) * distance}px`);
            microBubble.style.setProperty('--tr', `${(Math.random() - 0.5) * 180}deg`);
            microBubble.style.setProperty('--wobble-x', `${Math.random() * 5}px`);
            
            bubbleContainer.appendChild(microBubble);
            
            // Animacja mikrobąbelków - szybka, prawie natychmiastowa
            microBubble.style.animation = `micro-bubble-form 0.5s ease-out forwards`;
            
            // Czyszczenie
            setTimeout(() => {
              try {
                microBubble.remove();
              } catch (error) {
                // Ignoruj błędy podczas usuwania
              }
            }, 600);
          } catch (error) {
            console.warn("Błąd podczas tworzenia mikrobąbelka", error);
            continue;
          }
        }
      }

      // Funkcja tworząca falę bąbelków z ulepszoną fizyką
      function createBubbleWave(numBubbles, originX, originY, angle, waveOffsetFactor, speedFactor) {
        for (let i = 0; i < numBubbles; i++) {
          try {
            const tinyBubble = document.createElement('div');
            tinyBubble.className = 'tiny-bubble';
            
            // Dodawanie podświetleń do bąbelków
            if (Math.random() > 0.3) { // 70% bąbelków ma podświetlenia
              const highlight = document.createElement('div');
              highlight.className = 'highlight highlight-small';
              highlight.style.width = '40%';
              highlight.style.height = '40%';
              highlight.style.top = `${15 + Math.random() * 10}%`;
              highlight.style.left = `${15 + Math.random() * 10}%`;
              highlight.style.borderRadius = `${40 + Math.random() * 20}% ${60 - Math.random() * 20}% ${50 + Math.random() * 10}% ${50 - Math.random() * 10}%`;
              highlight.style.transform = `rotate(${Math.random() * 30 - 15}deg)`;
              tinyBubble.appendChild(highlight);
            }
            
            // Bardziej zróżnicowana dystrybucja rozmiaru
            const sizeRandom = Math.random();
            let size;
            
            if (sizeRandom < 0.5) { // 50% szans na malutkie bąbelki
              size = 2 + sizeRandom * 3; // 2-5px
            } else if (sizeRandom < 0.85) { // 35% szans na średnie bąbelki
              size = 5 + (sizeRandom - 0.5) * 10 / 0.35; // 5-10px
            } else { // 15% szans na większe bąbelki
              size = 10 + (sizeRandom - 0.85) * 8 / 0.15; // 10-18px
            }
            
            // Skoryguj rozmiar zgodnie z falą (późniejsze fale mają inne rozmiary)
            size = size * (1 - waveOffsetFactor * 0.2);
            
            tinyBubble.style.width = `${size}px`;
            tinyBubble.style.height = `${size}px`;
            
            // Ulepszony wygląd bąbelka
            const opacity = 0.2 + Math.random() * 0.15;
            tinyBubble.style.background = `rgba(0, 112, 243, ${opacity})`;
            tinyBubble.style.boxShadow = `inset 0 0 ${size/2}px rgba(255, 255, 255, 0.5), 
                                          0 0 ${size/3}px rgba(0, 112, 243, 0.25)`;
            
            // Delikatnie nieregularny kształt
            const radiusBase = 50;
            const radiusVariation = 5 - size/4; // Mniejsze bąbelki są bardziej nieregularne
            tinyBubble.style.borderRadius = `${radiusBase + Math.random() * radiusVariation}% 
                                            ${radiusBase - Math.random() * radiusVariation}% 
                                            ${radiusBase + Math.random() * radiusVariation}% 
                                            ${radiusBase - Math.random() * radiusVariation}%`;
            
            // Początkowa pozycja z dystrybucją radialną
            const radialDistance = Math.random() * 12 * (1 + waveOffsetFactor * 0.8);
            const radialAngle = angle + (Math.random() - 0.5) * Math.PI * (0.8 - waveOffsetFactor * 0.3); // Stożek rozproszenia
            
            const offsetX = Math.cos(radialAngle) * radialDistance;
            const offsetY = Math.sin(radialAngle) * radialDistance;
            
            tinyBubble.style.left = `${originX + offsetX}px`;
            tinyBubble.style.top = `${originY + offsetY}px`;
            
            // Fizyka oparta na rozmiarze
            const buoyancyFactor = 1 - (size / 20); // Mniejsze bąbelki rozpraszają się bardziej losowo
            const primaryDirection = Math.PI / 2; // Kierunek w górę
            
            // Mieszanie między kierunkiem rozerwania a kierunkiem w górę w zależności od rozmiaru
            const blendedAngle = angle * buoyancyFactor + primaryDirection * (1 - buoyancyFactor);
            
            // Dodajemy losowość proporcjonalną do rozmiaru
            const finalAngle = blendedAngle + (Math.random() - 0.5) * Math.PI * buoyancyFactor;
            
            // Dystans proporcjonalny do rozmiaru
            const baseDistance = 50 + size * 4;
            const distance = baseDistance + Math.random() * 60;
            
            // Większe bąbelki unoszą się szybciej dzięki wyporności
            const sizeFactor = 0.7 + (size / 15);
            
            // Ostateczny mnożnik prędkości uwzględniający czynnik fali
            const finalSpeedFactor = sizeFactor * speedFactor;
            
            // Obliczanie ostatecznych wektorów ruchu
            const tx = Math.sin(finalAngle) * distance * finalSpeedFactor;
            const ty = -Math.abs(Math.cos(finalAngle) * distance * finalSpeedFactor); // Zawsze unoszenie w górę
            
            // Większa rotacja dla mniejszych bąbelków
            const tr = (Math.random() - 0.5) * (180 - size * 8); 
            
            // Zakłócenia trajektorii dla realistycznej dynamiki płynów
            const wobbleX = Math.random() * 15 * (1 - size/18); // Mniejsze bąbelki bardziej się kołyszą
            
            // Ustawienie zmiennych CSS dla animacji
            tinyBubble.style.setProperty('--tx', `${tx}px`);
            tinyBubble.style.setProperty('--ty', `${ty}px`);
            tinyBubble.style.setProperty('--tr', `${tr}deg`);
            tinyBubble.style.setProperty('--wobble-x', `${wobbleX}px`);
            
            // Dodanie do kontenera
            bubbleContainer.appendChild(tinyBubble);
            
            // Rozłożone czasy rozpoczęcia animacji dla bardziej naturalnego efektu
            const startDelay = i * 25 + Math.random() * 50;
            
            // Zróżnicowany czas trwania animacji w zależności od rozmiaru
            const duration = 1 + size/10 + Math.random() * 0.7;
            
            // Uruchomienie animacji
            setTimeout(() => {
              tinyBubble.style.animation = `tinyBubbleRise ${duration}s ease-out forwards`;
              
              // Usunięcie po zakończeniu animacji
              setTimeout(() => {
                try {
                  tinyBubble.remove();
                } catch (error) {
                  // Ignoruj błędy podczas usuwania
                }
              }, duration * 1000 + 100);
            }, startDelay);
          } catch (error) {
            console.warn("Błąd podczas tworzenia bąbelka w fali", error);
            continue; // Kontynuuj tworzenie innych bąbelków mimo błędu
          }
        }
      }

      // Funkcja dodająca efekty po separacji
      function addPostSeparationEffects() {
        // Dodawanie małych cząstek powstających w punkcie separacji
        for (let i = 0; i < 8; i++) { // Zwiększona liczba cząstek
          setTimeout(() => {
            try {
              const particle = document.createElement('div');
              particle.className = 'particle';
              
              // Mała losowa wielkość
              const size = 1.5 + Math.random() * 3.5;
              particle.style.width = `${size}px`;
              particle.style.height = `${size}px`;
              
              // Pozycja blisko punktu separacji
              const mainRect = mainBubble.getBoundingClientRect();
              const redirectRect = redirectBubble.getBoundingClientRect();
              const containerRect = bubbleContainer.getBoundingClientRect();
              
              const mainCenterX = mainRect.left - containerRect.left + mainRect.width / 2;
              const mainCenterY = mainRect.top - containerRect.top + mainRect.height / 2;
              const redirectCenterX = redirectRect.left - containerRect.left + redirectRect.width / 2;
              const redirectCenterY = redirectRect.top - containerRect.top + redirectRect.height / 2;
              
              // Punkt między dwoma bąbelkami, bliżej głównego
              const midX = mainCenterX + (redirectCenterX - mainCenterX) * 0.4;
              const midY = mainCenterY + (redirectCenterY - mainCenterY) * 0.38;
              
              // Dodaj losowe odchylenie
              const offsetX = (Math.random() - 0.5) * 10;
              const offsetY = (Math.random() - 0.5) * 10;
              
              particle.style.left = `${midX + offsetX}px`;
              particle.style.top = `${midY + offsetY}px`;
              
              // Losowe parametry animacji - głównie unoszenie w górę
              particle.style.setProperty('--x-offset', `${Math.random() * 50 - 25}px`);
              particle.style.setProperty('--y-offset', `${-40 - Math.random() * 40}px`);
              
              // Opóźnienie dla animacji
              particle.style.animationDelay = `0s`;
              particle.style.animationDuration = `${3 + Math.random() * 3}s`;
              
              // Dodaje lepszą widoczność
              particle.style.opacity = `${0.1 + Math.random() * 0.1}`;
              
              // Dodanie do kontenera
              bubbleContainer.appendChild(particle);
              
              // Usunięcie po animacji
              setTimeout(() => {
                try {
                  particle.remove();
                } catch (error) {
                  // Ignoruj błędy podczas usuwania cząstek
                }
              }, 8000); // Dłuższy czas życia dla cząstek
            } catch (error) {
              console.warn("Błąd podczas tworzenia cząstki separacji", error);
            }
          }, i * 300); // Większe odstępy czasowe między cząstkami
        }
        
        // Dodatkowy efekt - pulsowanie bąbelków po separacji
        if (mainBubble) {
          mainBubble.style.animation = 'float-main-after 6s ease-in-out infinite, wobble-shape 6s infinite linear, bubble-surface-tension 4s ease-in-out infinite';
        }
        
        if (redirectBubble) {
          redirectBubble.style.animation = 'float-redirect 4s ease-in-out infinite, wobble-shape 6s infinite linear, bubble-surface-tension 3s ease-in-out infinite';
        }
      }
    });
  </script>
</body>
</html>