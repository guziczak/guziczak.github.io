<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Przekierowanie | Łukasz Guziczak</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: linear-gradient(135deg, #0066cc, #004080);
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      font-family: sans-serif;
    }
    
    .bubble-container {
      position: relative;
      width: 300px;
      height: 300px;
    }
    
    /* Style dla bąbelków */
    .bubble {
      position: absolute;
      /* Nieregularny kształt bąbelka */
      border-radius: 48% 52% 51% 49% / 51% 47% 53% 49%;
      background: rgba(255, 255, 255, 0.4);
      box-shadow: 
        inset 2px 2px 10px rgba(255, 255, 255, 0.8),
        inset -2px -2px 10px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Główny bąbelek */
    .main-bubble {
      width: 120px;
      height: 120px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
    }
    
    /* Reflektor światła w bąbelku */
    .bubble::before {
      content: '';
      position: absolute;
      width: 30%;
      height: 30%;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      top: 20%;
      left: 20%;
    }
    
    /* Mniejszy reflektor */
    .bubble::after {
      content: '';
      position: absolute;
      width: 15%;
      height: 15%;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      top: 35%;
      left: 35%;
    }
    
    /* Spinner w głównym bąbelku */
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s linear infinite;
    }
    
    /* Bąbelek przekierowujący */
    .redirect-bubble {
      width: 60px;
      height: 60px;
      left: calc(50% + 60px);
      top: calc(50% - 30px);
      z-index: 3; /* Wyższe z-index żeby był zawsze na wierzchu */
      border-radius: 51% 49% 48% 52% / 49% 51% 49% 51%;
      cursor: pointer;
      /* Stan początkowy - niewidoczny */
      opacity: 0;
      transform: translate(-50%, -50%) scale(0);
    }
    
    /* Strzałka w bąbelku przekierowującym */
    .arrow {
      width: 0;
      height: 0;
      border-top: 8px solid transparent;
      border-bottom: 8px solid transparent;
      border-left: 12px solid white;
      margin-left: 4px;
    }
    
    /* Tło dla animacji deformacji */
    .deform-background {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    /* Efekty bąbelków podczas rozdzielania */
    .tiny-bubble {
      position: absolute;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 49% 51% 52% 48% / 52% 48% 52% 48%;
      opacity: 0;
      transform-origin: center;
      z-index: 1;
    }
    
    /* Klasa dla animacji po rozdzieleniu bąbelków */
    .floating {
      animation: float 4s ease-in-out infinite;
    }
    
    .redirect-floating {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
      animation: float 3s ease-in-out infinite, pulse 1.5s infinite alternate;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
    }
    
    /* Animacje */
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    @keyframes float {
      0% { transform: translate(-50%, -50%) translateY(0) rotate(0deg); }
      50% { transform: translate(-50%, -50%) translateY(-10px) rotate(1deg); }
      100% { transform: translate(-50%, -50%) translateY(0) rotate(0deg); }
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
    }
    
    /* Animacja głównego bąbelka podczas rozdzielania */
    @keyframes mainBubbleDeform {
      0% {
        transform: translate(-50%, -50%) scale(1);
        border-radius: 48% 52% 51% 49% / 51% 47% 53% 49%;
      }
      40% {
        transform: translate(-60%, -50%) scale(1.1, 0.9);
        border-radius: 40% 60% 45% 55% / 45% 50% 50% 55%;
      }
      70% {
        transform: translate(-65%, -50%) scale(0.97);
        border-radius: 45% 55% 47% 53% / 47% 49% 51% 53%;
      }
      85% {
        transform: translate(-55%, -50%) scale(0.95);
        border-radius: 47% 53% 49% 51% / 49% 48% 52% 51%;
      }
      100% {
        transform: translate(-50%, -50%) scale(0.9);
        border-radius: 49% 51% 50% 50% / 50% 49% 51% 50%;
      }
    }
    
    /* Animacja dla nowo powstającego bąbelka */
    @keyframes newBubbleForm {
      0% {
        opacity: 0;
        transform: translate(-130%, -50%) scale(0.2);
        border-radius: 60% 40% 55% 45% / 55% 45% 55% 45%;
      }
      30% {
        opacity: 0.3;
        transform: translate(-100%, -50%) scale(0.4);
        border-radius: 55% 45% 52% 48% / 52% 48% 52% 48%;
      }
      60% {
        opacity: 0.7;
        transform: translate(-80%, -50%) scale(0.7);
        border-radius: 52% 48% 51% 49% / 51% 49% 51% 49%;
      }
      80% {
        opacity: 0.9;
        transform: translate(-60%, -50%) scale(0.9);
        border-radius: 51% 49% 50% 50% / 50% 50% 50% 50%;
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        border-radius: 51% 49% 48% 52% / 49% 51% 49% 51%;
      }
    }
    
    /* Animacja dla łącznika podczas rozdzielania */
    @keyframes connectorAnimation {
      0% {
        opacity: 0;
        transform: scaleX(0) translateX(0);
        height: 0;
        width: 0;
        border-radius: 50%;
      }
      10% {
        opacity: 1;
        height: 30px;
        transform: scaleX(0.2) translateX(10px);
        border-radius: 40% 60% 40% 60%;
      }
      40% {
        opacity: 1;
        width: 45px;
        height: 25px;
        transform: scaleX(1) translateX(35px);
        border-radius: 35% 65% 35% 65% / 45% 55% 45% 55%;
      }
      70% {
        opacity: 0.8;
        width: 20px;
        height: 15px;
        transform: scaleX(0.7) translateX(60px);
        border-radius: 40% 60% 40% 60% / 48% 52% 48% 52%;
      }
      90% {
        opacity: 0.4;
        width: 10px;
        height: 10px;
        transform: scaleX(0.3) translateX(80px);
        border-radius: 45% 55% 45% 55%;
      }
      100% {
        opacity: 0;
        transform: scaleX(0) translateX(100px);
        height: 0;
        border-radius: 50%;
      }
    }
    
    /* Animacja unoszenia małych bąbelków */
    @keyframes tinyBubbleRise {
      0% {
        opacity: 1;
        transform: translate(0, 0) scale(1) rotate(0deg);
      }
      70% {
        opacity: 0.7;
      }
      100% {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(0.3) rotate(var(--tr));
      }
    }
  </style>
</head>
<body>
  <div class="bubble-container" id="bubbleContainer">
    <div class="deform-background" id="deformBackground"></div>
    <div class="bubble main-bubble" id="mainBubble">
      <div class="spinner"></div>
    </div>
    <div class="bubble redirect-bubble" id="redirectBubble">
      <div class="arrow"></div>
    </div>
  </div>

  <script>
    // Konfiguracja
    const autoRedirectEnabled = true; // Hardcoded flaga dla auto-redirect
    const redirectUrl = "https://guziczak.github.io/lukasz/";
    const splitDelay = 500; // ms po których rozpocznie się animacja separacji
    const totalAutoRedirectDelay = 1000; // całkowity czas w ms do auto-przekierowania od momentu załadowania strony
    
    document.addEventListener('DOMContentLoaded', () => {
      const bubbleContainer = document.getElementById('bubbleContainer');
      const mainBubble = document.getElementById('mainBubble');
      const redirectBubble = document.getElementById('redirectBubble');
      const deformBackground = document.getElementById('deformBackground');
      
      // Przekierowanie po kliknięciu w bąbelek
      redirectBubble.addEventListener('click', () => {
        window.location.href = redirectUrl;
      });
      
      // Rozpocznij asynchroniczne odliczanie do automatycznego przekierowania
      if (autoRedirectEnabled) {
        setTimeout(() => {
          window.location.href = redirectUrl;
        }, totalAutoRedirectDelay);
      }
      
      // Rozpocznij animację rozdzielania po opóźnieniu
      setTimeout(startSeparationAnimation, splitDelay);
      
      // Funkcja rozpoczynająca animację separacji bąbelków
      function startSeparationAnimation() {
        // 1. Utwórz element łącznika (connector)
        const connector = document.createElement('div');
        connector.className = 'bubble';
        connector.style.position = 'absolute';
        connector.style.zIndex = '1';
        
        // Pozycja początkowa łącznika
        const mainRect = mainBubble.getBoundingClientRect();
        const containerRect = bubbleContainer.getBoundingClientRect();
        
        const mainCenterX = mainRect.left - containerRect.left + mainRect.width / 2;
        const mainCenterY = mainRect.top - containerRect.top + mainRect.height / 2;
        
        connector.style.left = `${mainCenterX}px`;
        connector.style.top = `${mainCenterY}px`;
        connector.style.transformOrigin = 'left center';
        
        deformBackground.appendChild(connector);
        
        // 2. Rozpocznij animacje deformacji i formowania
        // Te animacje trwają 0.8s (800ms)
        mainBubble.style.animation = 'mainBubbleDeform 0.8s forwards';
        redirectBubble.style.animation = 'newBubbleForm 0.8s forwards';
        connector.style.animation = 'connectorAnimation 0.8s forwards';
        
        // 3. Utwórz efekt małych bąbelków przy rozrywaniu
        setTimeout(createBubbleBreakEffect, 350);
        
        // 4. Po zakończeniu animacji separacji
        setTimeout(() => {
          // Usuń element łącznika
          connector.remove();
          
          // Wyraźnie ustaw style dla bąbelka przekierowującego
          redirectBubble.classList.add('redirect-floating');
          
          // Zastosuj animację pływania dla głównego bąbelka
          mainBubble.classList.add('floating');
          
        }, 850);
      }
      
      // Tworzy efekt bąbelków przy rozdzielaniu
      function createBubbleBreakEffect() {
        // Pozycja, gdzie pojawią się małe bąbelki
        const mainRect = mainBubble.getBoundingClientRect();
        const redirectRect = redirectBubble.getBoundingClientRect();
        const containerRect = bubbleContainer.getBoundingClientRect();
        
        // Środek pomiędzy głównym i nowym bąbelkiem (punkt rozerwania)
        const centerX = mainRect.right - containerRect.left + (redirectRect.left - mainRect.right) / 2;
        const centerY = (mainRect.top + mainRect.bottom) / 2 - containerRect.top;
        
        // Utwórz 10-15 małych bąbelków
        const numBubbles = 10 + Math.floor(Math.random() * 6);
        
        for (let i = 0; i < numBubbles; i++) {
          const tinyBubble = document.createElement('div');
          tinyBubble.className = 'tiny-bubble';
          
          // Losowy rozmiar (mniejsze bąbelki)
          const size = 3 + Math.random() * 10;
          tinyBubble.style.width = `${size}px`;
          tinyBubble.style.height = `${size}px`;
          
          // Losowy nieregularny kształt
          const randomRadius = () => {
            const base = 45 + Math.random() * 10;
            return `${base}% ${100-base}% ${base+Math.random()*5}% ${100-base-Math.random()*5}%`;
          };
          
          tinyBubble.style.borderRadius = `${randomRadius()} / ${randomRadius()}`;
          
          // Pozycja początkowa - lekko rozproszona wokół punktu rozerwania
          const offsetX = (Math.random() - 0.5) * 10;
          const offsetY = (Math.random() - 0.5) * 10;
          
          tinyBubble.style.left = `${centerX + offsetX}px`;
          tinyBubble.style.top = `${centerY + offsetY}px`;
          
          // Kierunek ruchu - głównie do góry z lekkim rozproszeniem na boki
          const angle = (Math.random() - 0.5) * Math.PI * 0.6; // -90° do +90° od pionu
          const distance = 30 + Math.random() * 50;
          const tx = Math.sin(angle) * distance; // X to sin dla ruchu głównie w pionie
          const ty = -Math.cos(angle) * distance; // Y to -cos dla ruchu głównie w górę
          const rotation = (Math.random() - 0.5) * 60; // -30° do +30°
          
          tinyBubble.style.setProperty('--tx', `${tx}px`);
          tinyBubble.style.setProperty('--ty', `${ty}px`);
          tinyBubble.style.setProperty('--tr', `${rotation}deg`);
          
          // Dodaj do kontenera
          deformBackground.appendChild(tinyBubble);
          
          // Rozpocznij animację z lekkim opóźnieniem
          setTimeout(() => {
            tinyBubble.style.animation = `tinyBubbleRise ${0.6 + Math.random() * 0.6}s ease-out forwards`;
            
            // Usuń po zakończeniu animacji
            setTimeout(() => {
              tinyBubble.remove();
            }, 1200);
          }, i * 30); // Małe opóźnienie między każdym bąbelkiem
        }
      }
    });
  </script>
</body>
</html>